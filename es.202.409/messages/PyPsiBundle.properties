# Message we display for inspection if user uses custom class type members that do not exist
custom.type.mimic.name={0}에 기반한 동적 클래스

### Refactoring

refactoring.extract.method.error.interrupted.execution.flow=실행 흐름이 중단될 시 리팩토링을 수행할 수 없습니다.
refactoring.extract.method.error.star.import=코드 블록 내부의 별표 import 문으로 리팩토링을 수행할 수 없습니다.
refactoring.extract.method.error.yield=코드 블록 내부의 'yield' 문으로 리팩토링을 수행할 수 없습니다.

### Annotators ###
ANN.deleting.none=None 삭제
ANN.assign.to.none=None으로 할당
ANN.cant.assign.to.call=함수 호출에 할당할 수 없습니다.
ANN.cant.delete.call=함수 호출을 삭제할 수 없습니다.
ANN.cant.aug.assign.to.generator=생성기 표현식에 증강 할당할 수 없습니다.
ANN.cant.aug.assign.to.tuple.or.generator=튜플 리터럴 또는 생성기 표현식에 증강 할당할 수 없습니다.
ANN.cant.assign.to.generator=생성기 표현식에 할당할 수 없습니다.
ANN.cant.assign.to.operator=연산자에게 할당할 수 없습니다.
ANN.cant.assign.to.parens=() 에 할당할 수 없습니다.
ANN.cant.aug.assign.to.list.or.comprh=리스트 리터럴 또는 내포에 증강 할당할 수 없습니다.
ANN.cant.assign.to.comprh=리스트 내포에 할당할 수 없습니다.
ANN.cant.assign.to.dict.comprh=dict 내포에 할당할 수 없습니다.
ANN.cant.assign.to.set.comprh=집합 내포에 할당할 수 없습니다.
ANN.cant.aug.assign.to.comprh=리스트 내포에 증강 할당할 수 없습니다.
ANN.cant.aug.assign.to.dict.comprh=dict 내포에 증강 할당할 수 없습니다.
ANN.cant.aug.assign.to.set.comprh=집합 내포에 증강 할당할 수 없습니다.
ANN.cant.assign.to.literal=리터럴에 할당할 수 없습니다.
ANN.cant.delete.literal=리터럴을 삭제할 수 없습니다.
ANN.cant.assign.to.lambda=람다에 할당할 수 없습니다.

ANN.break.outside.loop=루프 외부의 'break'
ANN.continue.outside.loop=루프 외부의 'continue'

ANN.$0.assigned.before.global.decl=이름 ''{0}'' 이(가) 전역 선언 전에 할당됩니다.

ANN.duplicate.param.name=매개 변수 이름 중복
ANN.starred.param.after.kwparam=** 매개변수 이후 * 매개변수
ANN.regular.param.after.vararg=* 매개변수 후 일반 매개변수
ANN.regular.param.after.keyword=** 매개변수 후 일반 매개변수
ANN.non.default.param.after.default=디폴트 값이 아닌 매개변수가 디폴트 매개변수 뒤에 옵니다.
ANN.named.parameters.after.star=이름이 지정된 매개변수가 bare * 뒤에 와야 합니다.
ANN.named.parameters.before.slash=이름이 지정된 매개변수가 bare / 앞에 와야 합니다.
ANN.tuple.py3=Python 3에서 튜플 매개변수 풀기가 지원되지 않습니다.
ANN.multiple.args=여러 * 매개변수가 허용되지 않습니다.
ANN.multiple.kwargs=여러 ** 매개변수가 허용되지 않습니다.
ANN.multiple.slash=여러 / 매개변수가 허용되지 않습니다.
ANN.slash.param.after.vararg=/ 매개변수가 * 매개변수 앞에 와야 합니다.
ANN.slash.param.after.keyword=/ 매개변수가 ** 매개변수 앞에 와야 합니다.

ANN.star.import.at.top.only='import *'는 모듈 레벨에서만 허용됩니다.

ANN.missing.closing.quote=닫는 따옴표 [{0}] 누락
ANN.missing.closing.triple.quotes=닫는 삼중 따옴표 누락

ANN.method.$0.removed.use.$1=메소드 ''{0}'' 이(가) 제거되었으므로, 대신 ''{1}''을(를) 사용하십시오.
ANN.method.$0.removed=메소드 ''{0}'' 이(가) 제거되었습니다.

### parsing
PARSE.expected.expression=표현식이 필요합니다
PARSE.expected.rbracket=']' 가 필요합니다
PARSE.expected.expr.or.comma.or.bracket=표현식, ',' 또는 ']' 가 필요합니다
PARSE.expected.in='in' 이 필요합니다
PARSE.expected.for.or.bracket=']' 또는 'for' 가 필요합니다
PARSE.expected.comma=',' 가 필요합니다
PARSE.expected.colon='\:' 이 필요합니다
PARSE.expected.rpar=')' 가 필요합니다
PARSE.expected.lpar='(' 가 필요합니다
PARSE.expected.rbrace='}' 가 필요합니다
PARSE.expected.tick='`'(backtick) 이 필요합니다
PARSE.expected.name=이름이 필요합니다
PARSE.expected.colon.or.rbracket='\:' 또는 ']' 가 필요합니다
PARSE.expected.comma.or.rpar=',' 또는 ')' 가 필요합니다
PARSE.expected.else='else' 가 필요합니다

PARSE.expected.identifier=식별자가 필요합니다
PARSE.expected.comma.lpar.rpar=',' 또는 '(' 또는 ')' 가 필요합니다
PARSE.expected.statement.break=break 문이 필요합니다
PARSE.expected.@.or.def='@' 또는 'def' 이(가) 필요합니다
PARSE.expected.formal.param.name=형식 매개변수 이름 기대
PARSE.0.expected={0} 기대
PARSE.expected.ellipsis='...' 예상
PARSE.string.literal.expected=문자열 리터럴이 필요합니다
PARSE.expected.symbols={0} 또는 {1} 기대
PARSE.declarator.should.be.empty=선언자가 비어 있어야 합니다.
PARSE.string.literal=문자열 리터럴
PARSE.newline.expected=줄 바꿈이 필요합니다
PARSE.eq.expected='\=' 예상
PARSE.from.expected='from' 이 필요합니다
PARSE.gt.expected='>' 예상

statement.expected.found.0=명령문 기대, {0} 발견
unexpected.indent=예기치 않은 들여쓰기
unindent.does.not.match.any.outer.indent=들여쓰기 실행 취소가 다른 외부 들여쓰기 레벨과 일치하지 않습니다.
except.or.finally.expected='except' 또는 'finally' 기대
expected.statement=\ 구문이 필요합니다
dedent.expected=내어쓰기가 필요합니다
indent.expected=들여쓰기가 필요합니다
indented.block.expected=들여쓰기된 블록이 필요합니다
cannot.assign.to.yield.expression='yield' 식에 할당할 수 없습니다.
end.of.statement.expected=명령문의 끝이 필요합니다
import.expected='import' 가 필요합니다
def.or.with.or.for.expected='def' 또는 'with' 또는 'for' 가 필요합니다
rbracket.or.comma.expected='']'' 또는 '''','' 가 필요합니다
unexpected.expression.syntax=예기치 않은 표현식 구문
tuple.expression.expected=튜플 표현식이 필요합니다
value.expression.expected=값 표현식이 필요합니다
unexpected.expression.part=예기치 않은 표현식 부분
unexpected.f.string.token=예기치 않은 f 문자열 토큰
can.t.assign.to.await.expression=await 식에 할당할 수 없습니다.
for.expected='for' 가 필요합니다
rarrow.expected='->' 가 필요합니다
unexpected.tokens=예기치 않은 토큰
enable.in.python.3=Python 3+에서 활성화

PARSE.function.type.annotations.py2=Python 2에서 유형 어노테이션이 지원되지 않습니다.
PARSE.function.return.type.annotations.py2=Python 2에서 반환 유형 어노테이션이 지원되지 않습니다.

PARSE.console.multiline.magic.warn=여러 줄 매직을 표현식으로 사용할 수 없습니다.
PARSE.console.identifier.expected=식별자가 필요합니다
PARSE.console.help.request.warn=도움 요청은 이름 다음에 와야 합니다.

### quick doc generator
QDOC.module.path.unknown=(모듈 경로를 알 수 없습니다)
QDOC.epydoc.python2.sdk.not.found=\ <a href\='http\://epydoc.sourceforge.net/'> Epydoc</a> docstrings를 렌더링하려면 Python 2 SDK를 구성해야 합니다.
QDOC.local.sdk.not.found=docstrings을 렌더링하려면 구성된 로컬 Python SDK가 필요합니다.
QDOC.assigned.to=다음에 할당되었습니다\:
QDOC.documentation.is.copied.from=문서가 다음에서 복사됩니다\:
QDOC.accessor.kind=접근자 종류\:
QDOC.raises=발생\:
QDOC.keyword.args=키워드 args\:
QDOC.returns=리턴\:
QDOC.params=매개변수\:

### Formatter
formatter.panel.dict.alignment.do.not.align=정렬하지 않음
formatter.panel.dict.alignment.align.on.colon=콜론에 정렬
formatter.panel.dict.alignment.align.on.value=값에 정렬

ignore.overridden.functions=재정의된 함수 무시

### Intentions ###

INTN.replace.octal.numeric.literal=8진 숫자 리터럴을 지원 양식으로 변환
INTN.convert.builtin.import=내장 모듈 가져오기를 지원 양식으로 변환

INTN.Family.convert.except.part=except 부분을 지원 양식으로 변환
INTN.Family.convert.set.literal=집합 리터럴을 지원 양식으로 변환
INTN.Family.convert.builtin=내장 모듈 가져오기 변환
INTN.Family.convert.dict.comp.expression=사전 내포 표현식 변환
INTN.Family.convert.string=작은 따옴표 문자열을 큰따옴표로 변환


INTN.convert.to.from.$0.import.$1=''from {0} import {1}''(으)로 변환
INTN.convert.to.import.$0=''import {0}''(으)로 변환
INTN.convert.except.to=Convert 'except exceptClass,Target' to 'except exceptClass as Target'
INTN.convert.set.literal.to=집합 리터럴을 'set' 메소드 호출로 변환


INTN.alias.for.$0.dialog.title=''{0}''에 대한 별칭\:
INTN.add.alias.for.import.$0=''{0}''에 별칭 추가
INTN.remove.alias.for.import.$0=별칭 ''{0}'' 제거

INTN.Family.migration.to.python3=파이썬 3버전으로 마이그레이션 합니다

INTN.replace.noteq.operator=등호가 아닌 연산자 바꾸기
INTN.convert.dict.comp.to=사전 내포를 'dict' 메소드 호출로 변환

INTN.remove.leading.$0=선행 {0} 제거
INTN.remove.leading.prefix=접두사 제거

INTN.replace.backquote.expression=역인용 부호(`)를 바꾸십시오
INTN.replace.raise.statement=raise 문을 지원 양식으로 변환

INTN.replace.list.comprehensions=리스트 내포를 지원 양식으로 변환

# PyConvertToFStringIntention
INTN.convert.to.fstring.literal=f 문자열 리터럴로 변환
INTN.replace.with.method=str.format 메소드 호출로 교체

# ConvertFormatOperatorToMethodIntention
INTN.format.operator.to.method=형식 연산자 사용 위치를 str.format 메소드 호출로 변환

INTN.Family.convert.import.unqualify='import module' 에서 'from module import'으로 바꿉니다
INTN.Family.convert.import.qualify='from module import' 에서 'import module'으로 바꿉니다
INTN.Family.toggle.import.alias=가져오기 별칭 전환

INTN.replace.list.comprehensions.with.for=리스트 내포를 for 루프로 변환

INTN.replace.method=현재 파이썬 버전에서 지원하지 않는 메소드를 바꾸십시오

INTN.split.if=if 문 분할
INTN.split.if.text=if 문 2개로 분할

INTN.negate.comparison=비교 부정
INTN.negate.$0.to.$1=''{0}''을(를) ''{1}''(으)로 부정

INTN.string.concatenation.to.format=문자열 연결을 형식 연산자로 교체
INTN.replace.plus.with.format.operator=+를 문자열 서식 지정 연산자로 교체
INTN.replace.plus.with.str.format=+를 str.format 메소드 호출로 교체


INTN.flip.comparison=비교 반전
INTN.flip.$0=''{0}'' 반전
INTN.flip.$0.to.$1=''{0}'' 을(를)  ''{1}'' (으)로 반전

INTN.convert.string=작은 따옴표 문자열을 큰따옴표로 변환

INTN.join.if=if 문 결합
INTN.join.if.text=두 if 문 결합

INTN.convert.dict.constructor.to.dict.literal=dict 생성자를 dict 리터럴 형식으로 변환
INTN.convert.dict.literal.to.dict.constructor=dict 리터럴을 dict 생성자로 변환

INTN.quoted.string=작은 따옴표 및 큰따옴표로 문자열 간 변환
INTN.quoted.string.single.to.double=작은 따옴표 문자열을 큰따옴표 문자열로 변환
INTN.quoted.string.double.to.single=큰따옴표 문자열을 작은 따옴표 문자열로 변환

INTN.convert.lambda.to.function=람다를 함수로 변환

INTN.convert.variadic.param=가변에서 일반 매개변수로 변환

# PyConvertTripleQuotedStringIntention
INTN.triple.quoted.string=삼중 따옴표 문자열을 작은 따옴표 문자열로 변환

# PyBaseConvertCollectionLiteralIntention
INTN.convert.collection.literal.family=컬렉션을 {0}(으)로 변환 
INTN.convert.collection.literal.text={0} 을(를) {1}(으)로 변환

# PyConvertTypeCommentToVariableAnnotation
INTN.convert.type.comment.to.variable.annotation.family=유형 주석을 변수 어노테이션으로 변환
INTN.convert.type.comment.to.variable.annotation.text=변수 어노테이션으로 변환


INTN.demorgan.law=드모르간 법칙

# PyTransformConditionalExpressionIntention
INTN.transform.into.if.else.statement=조건식을 if/else 문으로 변환

# PyGenerateDocstringIntention
INTN.doc.string.stub=문서 문자열 스텁 삽입

#SpecifyTypeInDocstringIntention
INTN.specify.type=docstring 내 참조 유형 지정
INTN.specify.return.type=docstring 내 반환 유형 지정
INTN.add.parameters.to.docstring=docstring에 매개변수 추가

#SpecifyTypeInPy3AnnotationsIntention
INTN.specify.type.in.annotation=어노테이션를 사용하여 참조 유형 지정
INTN.specify.return.type.in.annotation=어노테이션를 사용하여 반환 유형 지정

#PyAnnotateTypesIntention/PyAnnotateVariableTypeIntention
INTN.add.type.hints.for.function.family=함수에 대한 유형 힌트 추가
INTN.add.type.hints.for.function=함수 ''{0}''에 대한 유형 힌트 추가
INTN.add.type.hint.for.variable.family=변수에 대한 유형 힌트 추가
INTN.add.type.hint.for.variable=변수 ''{0}''에 대한 형식 힌트 추가
INTN.add.type.hint.for.variable.PEP484.incompatible.type=유형 ''{0}''을(를) PEP 484 형식으로 인라인으로 표현할 수 없습니다.

#TypeAssertionIntention
INTN.insert.assertion=유형 어설션 삽입

#PyYieldFromIntention
INTN.yield.from='yield'를 사용한 명시적 반복을 'yield from' 식으로 변환

#PyConvertStaticMethodToFunctionIntention
INTN.convert.static.method.to.function=정적 메소드를 함수로 변환

#PyConvertMethodToPropertyIntention
INTN.convert.method.to.property=메소드를 프로퍼티로 변환

#PyConvertImportIntentionAction
INTN.convert.relative.to.absolute=상대 가져오기를 절대 가져오기로 변환
INTN.convert.absolute.to.relative=절대 가져오기를 상대 가져오기로 변환

INTN.add.alias.title=별칭 추가

### Quick fixes ###
QFIX.auto.import.family=가져오기
QFIX.auto.import.import.this.name=이 이름 가져오기
QFIX.auto.import.import.name=가져오기 ''{0}''
QFIX.local.auto.import.family=로컬로 가져오기
QFIX.local.auto.import.import.locally=로컬로 {0}
QFIX.augment.assignment=할당을 증강 할당으로 교체
QFIX.NAME.remove.call=호출 제거
QFIX.replace.equality=등식 대체
QFIX.dict.creation=딕셔너리 생성 대체
QFIX.NAME.remove.dict.key=이 키 제거
QFIX.NAME.move.except.up=except 절을 위로 이동
QFIX.add.field.to.class=\ 클래스에 필드 추가
QFIX.added.constructor.$0.for.field.$1=새 필드 <code>{1}</code>를 수용하기 위해<br/>__init__을 클래스에 <code>{0}</code>에추가했습니다. 
QFIX.NAME.remove.parameter=매개변수 제거
QFIX.rename.parameter.to.$0=''{0}''로 이름 바꾸기
QFIX.NAME.add.field.$0.to.class.$1={1} 클래스에 ''{0}''필드 추가
QFIX.NAME.remove.statement=구문 제거
QFIX.NAME.remove.target.expr=대상 표현식 제거
QFIX.failed.to.add.field=<br/>필드 추가 실패하였습니다\!<br/><br/>
QFIX.redundant.parentheses=중복 된 소괄호 제거
QFIX.simplify.boolean.expression=부울 표현식 단순화
QFIX.simplify.$0=부울 표현식을 ''{0}''로 대체합니다
QFIX.chained.comparison=체인 비교 간소화
QFIX.move.from.future.import=올바른 위치로 'from __future__ import' 이동
QFIX.list.creation=리스트 생성 대체
QFIX.add.super=상위 클래스 호출 추가
QFIX.NAME.remove.assignment=변수 지정 제거
QFIX.NAME.remove.argument=인수 제거
QFIX.add.parameter.self=파라메타 추가 ''{0}''
QFIX.statement.effect=함수 호출을 대체합니다
QFIX.remove.trailing.semicolon=후행 세미콜른 제거하기
QFIX.introduce.variable=명령문에 대한 변수 삽입
QFIX.NAME.make.list=튜플을 리스트로 교체
QFIX.NAME.add.specifier=형식 지정자 문자 추가
QFIX.NAME.wrap.in.exception=Exception 호출로 래핑
QFIX.add.global=전역 변수(global) 추가
QFIX.create.property=프로퍼티 만들기
QFIX.replace.with.type.name=유형 이름으로 교체
QFIX.remove.function.annotations=함수 어노테이션 제거
QFIX.replace.with.target.name=대상 이름으로 교체
QFIX.remove.generic.parameters=제네릭 매개변수 제거
QFIX.replace.with.square.brackets=대괄호로 교체
QFIX.surround.with.square.brackets=대괄호로 둘러싸기
QFIX.remove.square.brackets=대괄호 제거
QFIX.add.property=필드 프로퍼티 추가
QFIX.use.property=필드 프로퍼티 사용
QFIX.make.public=public으로 설정
QFIX.NAME.update.parameters=파라메타 업데이트 
QFIX.rename.parameter=매개변수 이름 변경
QFIX.convert.to.new.style=새로운 스타일의 클래스로 바꾸기
QFIX.change.base.class=기본 클래스 변경
QFIX.classic.class.transform=객체에서 상속받습니다
QFIX.NAME.rename.argument=인자 이름 바꾸기
QFIX.NAME.add.exception.base=Exception 기본 클래스 추가
QFIX.add.encoding=인코딩 선언 추가
QFIX.remove.trailing.suffix=후행 접미사 제거
QFIX.action.failed=작업이 실패 하였습니다


#PyRemoveUnderscoresInNumericLiteralsQuickFix
QFIX.NAME.remove.underscores.in.numeric=숫자 리터럴에서 밑줄을 제거하십시오

# ReplaceFunctionWithSetLiteralQuickFix
QFIX.replace.function.set.with.literal=함수 호출을 집합 리터럴로 교체

#RemoveArgumentEqualDefaultQuickFix
QFIX.remove.argument.equal.default=디폴트 값과 동일한 인수 제거

#PyDefaultArgumentQuickFix
QFIX.default.argument=변경 가능한 디폴트 인수 교체

#PyMoveAttributeToInitQuickFix
QFIX.move.attribute=속성을 __init__ 메소드로 이동

#DocstringQuickFix
QFIX.docstring.add.$0=docstring 매개변수 ''{0}'' 추가
QFIX.docstring.remove.$0=docstring 매개변수 ''{0}'' 제거
QFIX.docstring.insert.stub=docstring 삽입
QFIX.fix.docstring=docstring 수정

#PyMakeMethodStaticQuickFix
QFIX.NAME.make.static=메소드를 정적으로 만들기

#PyMakeFunctionFromMethodQuickFix
QFIX.NAME.make.function=메소드로부터 함수 생성

#ConvertIndents
QFIX.convert.indents=들여쓰기 변환
QFIX.convert.indents.to.tabs=들여쓰기를 탭으로 변환
QFIX.convert.indents.to.spaces=들여쓰기를 공백으로 변환

# ConvertDocstringQuickFix
QFIX.convert.single.quoted.docstring=docstring을 삼중 큰따옴표 문자열 양식으로 변환

# RemoveUnnecessaryBackslashQuickFix
QFIX.remove.unnecessary.backslash=표현식에서 불필요한 백슬래시 제거

#RemoveDecoratorQuickFix
QFIX.remove.decorator=데코레이터 제거

#PyMakeFunctionReturnTypeQuickFix
QFIX.NAME.make.$0.return.$1=''{0}''이(가) ''{1}''을(를) 반환하도록 만듭니다.

# Add method quick fix
QFIX.NAME.add.method.$0.to.class.$1={1} 클래스에 ''{0}''메소드 추가
QFIX.failed.to.add.method=<br/>메소드 추가 실패\!<br/><br/>
QFIX.NAME.add.function.$0.to.module.$1={1} 모듈에 {0}() 함수 생성
QFIX.failed.to.add.function=<br/>함수 추가 실패하였습니다\!<br/><br/>
QFIX.add.method.to.class=클래스에 메소드 추가

# InstallAndImportQuickFix
QFIX.install.and.import.package=패키지를 설치하고 가져옵니다
QFIX.NAME.install.and.import.package=''{0}''패키지를 설치하고 가져옵니다


# Actions and associated commands
ACT.CMD.use.import=가져온 모듈 사용
ACT.qualify.with.module=가져온 모듈 검증
ACT.from.some.module.import=...으로부터 가져오기


python.docstring.file.type=python docstring
python.function.type.annotation.file.type.description=Python PEP-484 함수 유형 주석
python.docstring.format=Docstring 형식\:
python.docstring.select.type=Docstring 유형 선택

### Inspections: INSP ###
INSP.GROUP.python=Python

INSP.compatibility.this.syntax.available.only.since.py3=이 구문은 py3 이후에서만 사용할 수 있습니다.
INSP.compatibility.check.for.compatibility.with.python.versions=Python 버전과의 호환성을 확인하십시오\:
INSP.abstract.class.set.as.metaclass=''{0}''을(를) 메타 클래스로 설정
INSP.abstract.class.add.to.superclasses=상위 클래스에 ''{0}'' 추가
INSP.pep8.naming=PEP 8 이름 지정 규칙 위반
INSP.pep8.naming.excluded.base.classes=제외된 기본 클래스
INSP.pep8.naming.ignored.errors=무시된 오류
INSP.shadowing.builtins=기본 가림
INSP.calling.non.callable=호출할 수 없는 객체를 호출하려고 합니다.
INSP.dataclass.definition.and.usages=데이터클래스 정의 및 사용 위치
INSP.dunder.slots=클래스 내 __slots__ 정의
INSP.final.classes.methods.and.variables=final 클래스, 메소드 및 변수
INSP.global.undefined=전역 변수가 모듈 수준에서 undefined입니다.
INSP.inconsistent.indentation=일관되지 않은 들여쓰기
INSP.named.tuple=Namedtuple 정의
INSP.shadows.name.from.outer.scope=외부 범위의 이름 ''{0}'' 가리기
INSP.trailing.semicolon=명령문 내 후행 세미콜론
INSP.raising.string.exception=문자열 예외 발생
INSP.protected.member.ignore.annotations=어노테이션 무시
INSP.protected.member.ignore.test.functions=테스트 함수 무시
INSP.docstring.types.fix.docstring=docstring 수정
INSP.docstring.types.change.type={0} 유형을 {1}에서 {2}(으)로 변경
INSP.interpreter.configure.python.interpreter=Python 인터프리터 구성
INSP.interpreter.interpreter.settings=인터프리터 설정
INSP.interpreter.use.interpreter={0} 사용
INSP.interpreter.use.suggested.interpreter=제안된 인터프리터 사용
INSP.mandatory.encoding.encoding.comment.format=주석 형식 인코딩\:
INSP.mandatory.encoding.select.default.encoding=디폴트 인코딩 선택\:
INSP.mandatory.encoding.no.encoding.specified.for.file=파일에 대해 지정된 인코딩이 없습니다.
INSP.method.parameters.metaclass.method.first.argument.name=메타 클래스 메소드 첫 번째 인수 이름
INSP.missing.type.hints.add.type.hints=유형 힌트 추가
INSP.missing.type.hints.add.type.hints.for=''{0}''에 대한 유형 힌트 추가
INSP.missing.type.hints.only.when.types.are.known.collected.from.run.time.or.inferred=유형이 알려진 경우에만(런타임에서 수집되거나 유추)

INSP.package.requirements.requirements.have.been.ignored=요구 사항이 무시되었습니다.
INSP.package.requirements.requirement.has.been.ignored=''{0}'' 이(가) 무시되었습니다.
INSP.package.requirements.add.import=import 문 추가
INSP.package.requirements.administrator.privileges.required=관리자 권한 필요
INSP.package.requirements.administrator.privileges.required.description=''{0}''로 패키지를 설치하려면 관리자 권한이 필요합니다.\n\
\n\
파일 시스템의 보호된 영역에 프로젝트를 설치하지 않도록 프로젝트별 가상 환경을 프로젝트 인터프리터로 구성하십시오.
INSP.package.requirements.administrator.privileges.required.button.configure=구성
INSP.package.requirements.administrator.privileges.required.button.install.anyway=그래도 설치
INSP.package.requirements.requirements.file.empty=요구 사항 파일이 비어 있습니다.
INSP.package.requirements.quickfix.family.name=요구 사항에 가져온 패키지 추가...
INSP.pep8.ignore.base.class=기본 클래스 무시
INSP.pep8.ignore.method.names.for.descendants.of.class=하위 클래스에 대한 메소드 이름 무시
INSP.shadowing.builtins.ignore.shadowed.built.in.name=가려진 내장 이름 무시
INSP.stub.packages.compatibility.ignore=''{0}'' 호환성 무시
INSP.stub.packages.compatibility.ignored.packages=무시한 스텁 패키지
INSP.stub.packages.compatibility.incompatible.packages.message=''{0}{1}{2}''은(는) ''{3}{4}{5}''와(과) 호환되지 않습니다. ''{6}'' 버전이 필요합니다\: [{7}]
INSP.arguments.not.declared.but.provided.by.decorator=다음 인수가 선언되지 않지만 데코레이터에 의해 제공됩니다\: {0}
INSP.abstract.class=클래스는 모든 추상 메소드를 구현해야 합니다.
INSP.assigning.function.call.that.doesnt.return.anything=아무 것도 반환하지 않는 함수 호출 할당
INSP.deprecated.function.class.or.module=더 이상 사용되지 않는 함수, 클래스 또는 모듈
INSP.mandatory.encoding=파일에 대해 지정된 인코딩이 없습니다.
INSP.missing.type.hints=함수 정의에 대한 유형 힌트가 누락되었습니다.
INSP.overloads.in.regular.python.files=일반 Python 파일의 오버로드
INSP.pep8.coding.style.violation=PEP 8 코딩 스타일 위반
INSP.protected.member=클래스 또는 모듈의 보호된 멤버에 대한 액세스
INSP.protocol.definition.and.usages=프로토콜 정의 및 사용 위치
INSP.shadowing.names=외부 범위로부터 이름 가림
INSP.stub.packages.compatibility=스텁 패키지 호환성 검사
INSP.stub.packages=스텁 패키지 애드버타이저
INSP.type.checker=유형 검사기
INSP.type.hints=유형 힌트 정의 및 사용 위치
INSP.typed.dict=TypedDict 정의 및 사용 위치

# PyArgumentListInspection
INSP.NAME.incorrect.call.arguments=잘못된 호출 인수
INSP.cannot.appear.past.keyword.arg=과거 키워드 인수 또는 *arg 또는 **kwarg를 표시할 수 없습니다.
INSP.unexpected.arg=예기치 않은 인수
INSP.unexpected.arg(s)=예기치 않은 인수
INSP.parameter.$0.unfilled=매개변수 ''{0}'' 이(가) 채워지지 않았습니다.
INSP.parameter(s).unfilled=매개변수가 채워지지 않았습니다.
INSP.possible.callees=가능한 피호출자
INSP.func.$0.lacks.first.arg=함수 ''{0}''에 위치 인수가 부족합니다.
INSP.expected.dict.got.$0=Expected a dictionary,got {0}
INSP.expected.iter.got.$0=Expected an iterable,got {0}
INSP.more.args.that.pos.params=여러 값이 하나의 위치 매개변수로 사용됩니다.
INSP.multiple.values.resolve.to.positional.$0=여러 값이 위치 매개변수 ''{0}''(으)로 사용됩니다.
INSP.cannot.analyze=이 인수 목록을 분석할 수 없습니다.

# PyMethodParametersInspection
INSP.NAME.problematic.first.parameter=첫 번째 매개변수에 문제가 있는 메소드
INSP.must.have.first.parameter=Method must have a first parameter,usually called ''{0}''
INSP.probably.mistyped.self='self'가 아닙니까?
INSP.usually.named.self=일반적으로 메소드의 첫 번째 매개변수는 'self'로 이름이 지정됩니다.
INSP.usually.named.$0=일반적으로 이러한 메소드의 첫 번째 매개변수는 ''{0}''로 이름이 지정됩니다.
INSP.first.param.must.not.be.tuple=비 static 메소드의 첫 번째 매개변수는 튜플이 아니어야 합니다

# PyNestedDecoratorsInspection
INSP.NAME.nested.decorators=데코레이터의 문제 있는 중첩
INSP.decorator.receives.unexpected.builtin=이 데코레이터는 기대하는 호출 가능한 객체를 받지 않으며, 내장 데코레이터가 특수 객체를 반환합니다.

# PyRedeclarationInspection
INSP.NAME.redeclaration=사용되지 않고 다시 선언된 이름
INSP.redeclared.name=위에서 정의된 ''{0}'' 이(가) 사용되지 않고 다시 선언되었습니다.

# PyUnresolvedReferencesInspection
INSP.try.except.import.error=''except ImportError''가 있는 try 블록의 ''{0}'' 이(가) except 블록 안에서도 정의되어야 합니다.
INSP.unused.import.statement=사용되지 않는 import 문 <code>\#ref</code>

# PyInterpreterInspection
INSP.NAME.invalid.interpreter=유효하지 않은 인터프리터가 구성되었습니다.

# ReturnValueFromInitInspection
INSP.NAME.init.return=값을 반환하는 __init__ 메소드
INSP.cant.return.value.from.init=__init__에서 값을 반환할 수 없습니다.

# PyUnreachableCodeInspection
INSP.NAME.unreachable.code=사용할 수 없는 코드
INSP.unreachable.code=이 코드에 도달할 수 없습니다.

# PyStringFormatInspection
INSP.NAME.str.format=문자열 서식 지정 작업 오류
INSP.format.requires.no.mapping=형식에는 매핑이 필요하지 않습니다.
INSP.key.$0.has.no.arg=키 ''{0}''에 해당 인수가 없습니다.
INSP.unexpected.type.$0=예기치 않은 유형 {0}
INSP.too.few.keys=매핑 키가 너무 적습니다.
INSP.no.format.specifier.char=형식 지정자 문자가 누락되었습니다.
INSP.format.requires.mapping=형식에는 매핑이 필요합니다.
INSP.too.many.args.for.fmt.string=형식 문자열에 대한 인수가 너무 많습니다.
INSP.too.few.args.for.fmt.string=형식 문자열에 대한 인수가 너무 적습니다.
INSP.incompatible.options=청크 "{0}"의 형식 옵션이 호환되지 않습니다.
INSP.unused.mapping = 매핑 키 "{0}" 이(가) 사용되지 않습니다.
INSP.unsupported.format.character=지원되지 않는 형식 문자 ''{0}''
INSP.manual.to.auto.field.numbering=수동 필드 사양에서 자동 필드 번호 표기로 전환할 수 없습니다.
INSP.auto.to.manual.field.numbering=자동 필드 번호 표기에서 수동 필드 사양으로 전환할 수 없습니다.

# PyMethodOverridingInspection
INSP.NAME.method.over=메소드 시그니처가 재정의된 메소드의 시그니처와 일치하지 않습니다.
INSP.signature.mismatch=메소드 ''{0}''의 시그니처가 클래스 ''{1}'' 기본 메소드의 시그니처와 일치 하지 않습니다.

# PyInitNewSignatureInspection
INSP.NAME.new.init.signature=호환되지 않는 __new__ 및 __init__ 시그니처
INSP.new.incompatible.to.init=시그니처가 __init__로 호환되지 않습니다. 
INSP.init.incompatible.to.new=시그니처가 __new__로 호환되지 않습니다. 

# PyTrailingSemicolonInspection
INSP.NAME.trailing.semicolon=명령문 내 후행 세미콜론


# PyUnboundLocalVariableInspection
INSP.NAME.unbound=바인딩되지 않은 지역 변수
INSP.unbound.local.variable=지역 변수 ''{0}'' 이(가) 할당 전에 참조될 수 있습니다.
INSP.unbound.nonlocal.variable=비지역 변수 ''{0}''을(를) 외부 함수 범위에 바인딩해야 합니다.
INSP.unbound.name.undefined=이름 ''{0}'' 이(가) undefined일 수 있습니다.
INSP.unbound.function.too.large=함수 ''{0}'' 이(가) 너무 커서 분석할 수 없습니다.

# PyListCreationInspection
INSP.NAME.list.creation=리스트 생성을 리스트 리터럴로 다시 작성할 수 있습니다.

# PyTupleAssignmentBalanceInspection
INSP.NAME.incorrect.assignment=튜플 할당 밸런스가 올바르지 않습니다.

# PyClassicStyleClassInspection
INSP.NAME.classic.class.usage=클래식 스타일 클래스 사용 위치
INSP.classic.class.usage.old.style.class=이전 스타일 클래스
INSP.classic.class.usage.old.style.class.ancestors=Old-style class,because all classes from whom it inherits are old-style


# PyExceptionInheritance
INSP.NAME.exception.not.inherit=예외는 표준 'Exception' 클래스를 상속하지 않습니다.

# PyDefaultArgumentInspection
INSP.NAME.default.argument=디폴트 인수는 변경 가능합니다.

# PyDocstringTypesInspection
INSP.NAME.docstring.types=docstring의 유형이 추론 유형과 일치하지 않습니다.

# PyStatementEffectInspection
INSP.NAME.statement.effect=명령문이 영향을 주지 않습니다.
INSP.NAME.statement.message=명령문이 아무 영향을 미치지 않는 것으로 보입니다.

# PyStringExceptionInspection
INSP.NAME.raising.string.exception=문자열 예외 발생

# PySuperArgumentsInspection
INSP.NAME.wrong.super.arguments=잘못된 super 호출 인수
INSP.$0.is.not.superclass.of.$1=''{0}'' 이(가) ''{1}''의 인스턴스 또는 하위 클래스가 아닙니다.

# PynonAsciiCharInspection
INSP.NAME.non.ascii=파일이 ASCII가 아닌 문자를 포함합니다.

# PyMandatoryEncodingInspection
INSP.NAME.mandatory.encoding=파일에 대해 지정된 인코딩이 없습니다.

# PyTupleItemAssignmentInspection
INSP.NAME.tuple.item.assignment=튜플 항목 할당
INSP.tuples.never.assign.items=Tuple이 항목 할당을 지원하지 않습니다.

# PyPropertyAccessInspection
INSP.NAME.property.access=프로퍼티에 대한 액세스
INSP.property.$0.cant.be.set=프로퍼티 ''{0}''을(를) 설정할 수 없습니다.
INSP.property.$0.cant.be.read=프로퍼티 ''{0}''을(를) 읽을 수 없습니다.
INSP.property.$0.cant.be.deleted=프로퍼티 ''{0}''을(를) 삭제할 수 없습니다.

# PyPropertyDefinitionInspection
INSP.NAME.property.definition=프로퍼티 정의
INSP.doc.param.should.be.str=doc 매개변수는 문자열이어야 합니다.
INSP.strange.arg.want.callable=이상한 인수; 호출 가능한 인수가 필요합니다
INSP.func.property.name.mismatch=함수 및 데코레이터 이름이 일치하지 않습니다. 프로퍼티 접근자가 생성되지 않았습니다.
INSP.getter.return.smth=getter가 무언가 반환하거나 산출해야합니다
INSP.setter.should.not.return=세터는 값을 반환해지 않아야 합니다.
INSP.deleter.should.not.return=삭제자는 값을 반환하지 않아야 합니다.
INSP.getter.signature.advice=getter 시그니처는 (self)이어야 합니다
INSP.setter.signature.advice=Setter signature should be (self,value)
INSP.deleter.signature.advice=삭제자 시그니처는 (self)이어야 합니다.
INSP.accessor.first.param.is.$0=접근자의 첫 번째 매개변수는 일반적으로 ''{0}''로 부릅니다.

# PyProtectedMemberInspection
INSP.protected.member.$0.access=\ 클래스의 protected 멤버 {0}에 대한 액세스
INSP.protected.member.$0.access.module=\ 모듈의 protected 멤버 {0}에 대한 액세스

# PyOldStyleClassesInspection
INSP.NAME.oldstyle.class=이전 스타일 클래스가 새로운 스타일의 클래스 기능을 포함합니다.
INSP.oldstyle.class.slots=이전 스타일 클래스가 __slots__ 정의를 포함합니다.
INSP.oldstyle.class.getattribute=이전 스타일 클래스가 __getattribute__ 정의를 포함합니다.
INSP.oldstyle.class.super=이전 스타일 클래스가 상위 메소드 호출을 포함합니다.

# PyCompatibilityInspection
INSP.NAME.compatibility=코드 호환성 검사

# PyUnnecessaryBackslashInspection
INSP.NAME.unnecessary.backslash=불필요한 백슬래시

# PySingleQuotedDocstringInspection
INSP.NAME.single.quoted.docstring=작은 따옴표 docstring
INSP.message.single.quoted.docstring=삼중 작은 따옴표 문자열이 docstrings에 사용되어야 합니다.

# PyMissingConstructorInspection
INSP.NAME.missing.super.constructor=누락된 상위 클래스 __init__ 호출
INSP.missing.super.constructor.message=상위 클래스 __init__ 호출이 누락되었습니다.

# PySetFunctionToLiteralInspection
INSP.NAME.set.function.to.literal=함수 호출을 집합 리터럴로 대체할 수 있습니다.

# PyDecoratorInspection
INSP.NAME.decorator.outside.class=클래스 외부 메소드의 클래스 특수 데코레이터

# PyPackageRequirementsInspection
INSP.NAME.requirements=패키지 요구 사항

# PyClassHasNoInitInspection
INSP.NAME.class.has.no.init=클래스에 __init__ 메소드가 없습니다.
INSP.class.has.no.init=클래스에 __init__ 메소드가 없습니다.
INSP.parent.$0.has.no.init=상위 클래스 ''{0}''에 __init__ 메소드가 없습니다.

#PyNoneFunctionAssignmentInspection
INSP.NAME.none.function.assignment=Assigning function call that doesn't return anything (없음)
INSP.none.function.assignment=함수 ''{0}'' 이(가) 아무것도 반환하지 않습니다.

# PyTestParametrizedInspection
INSP.NAME.pytest-parametrized=pytest parametrize로 장식된 함수에 올바른 인수가 있는지 확인합니다.

# PyUnusedLocalInspection
INSP.NAME.unused=사용되지 않는 로컬
INSP.unused.locals.parameter.isnot.used=매개변수 ''{0}'' 값이 사용되지 않습니다.
INSP.unused.locals.local.variable.isnot.used=지역 변수 ''{0}'' 값이 사용되지 않습니다.
INSP.unused.locals.replace.with.wildcard=_로 교체 
INSP.unused.locals.local.function.isnot.used=지역 함수 ''{0}'' 이(가) 사용되지 않습니다.
INSP.unused.locals.local.class.isnot.used=지역 클래스 ''{0}'' 이(가) 사용되지 않습니다.

INSP.unused.locals.ignore.variables.starting.with='_'로 시작하는 변수 무시
INSP.unused.locals.ignore.range.iteration.variables=범위 반복 변수 무시
INSP.unused.locals.ignore.lambda.parameters=람다 매개변수 무시
INSP.unused.locals.ignore.variables.used.in.tuple.unpacking=튜플 풀기에 사용되는 변수 무시

# PyChainedComparsonsInspection
INSP.NAME.chained.comparisons=체인 비교를 간소화할 수 있습니다.

# PyAugmentAssignmentInspection
INSP.NAME.augment.assignment=할당을 증강 할당으로 교체할 수 있습니다.

# PyBroadExceptionInspection
INSP.NAME.too.broad.exception.clauses=너무 광범위한 예외 절

# PyByteLiteralInspection
INSP.NAME.byte.literal=바이트 리터럴이 255개 이상의 문자를 포함합니다.

# PyComparisonWithNoneInspection
INSP.NAME.comparison.with.none=상등 연산자로 수행된 None과의 비교

# PyDictCreationInspection
INSP.NAME.dict.creation=사전 생성을 사전 리터럴로 다시 작성할 수 있습니다.

# PyDictDuplicateKeysInspection
INSP.NAME.duplicate.keys=사전이 중복 키를 포함합니다.

# PyFromFutureImportInspection
INSP.NAME.from.future.import=from __future__ import가 첫 번째 실행 명령문이어야 합니다.

# PyMethodFirstArgAssignmentInspection
INSP.NAME.first.arg.assign=메소드 첫 번째 인수 재할당
INSP.first.arg.$0.assigned=메소드 매개변수 ''{0}'' 이(가) 다시 할당되었습니다.

# PyMethodMayBeStaticInspection
INSP.NAME.method.may.be.static=메소드가 static일 수 있습니다.
INSP.method.may.be.static=메소드 <code>\#ref</code>가 'static'일 수 있습니다.

# PyAbstractClassInspection
INSP.NAME.abstract.class=클래스는 모든 추상 메소드를 구현해야 합니다.
INSP.NAME.abstract.class.$0.must.implement=클래스 {0} 이(가) 모든 추상 메소드를 구현해야 합니다.

#PyAssignmentToLoopOrWithParameterInspection
INSP.NAME.assignment.to.loop.or.with.parameter.display.name='for' 루프 또는 'with' 문 매개변수에 할당
INSP.NAME.assignment.to.loop.or.with.parameter.display.message=변수 ''{0}'' 이(가) 이미 위의 ''for'' 루프 또는 ''with'' 문에서 선언되었습니다.
INSP.assignment.to.loop.or.with.parameter='for' 루프 또는 'with' 문 매개변수에 할당

# PyArgumentEqualDefaultInspection
INSP.NAME.argument.equal.default=함수에 전달된 인수가 디폴트 매개변수 값과 같습니다.
INSP.argument.equals.to.default=인수가 디폴트 매개변수 값과 같습니다.

#PyAsyncCallInspection
INSP.NAME.coroutine.is.not.awaited=코루틴 ''{0}'' 은(는) 대기하고 있지 않습니다. 
INSP.async.call=코루틴은 대기하고 있지 않습니다.

# PyAttributeOutsideInitInspection
INSP.NAME.attribute.outside.init=인스턴스 속성이 __init__ 외부에 정의되었습니다.
INSP.attribute.$0.outside.init=__init__ 외부에 정의된 인스턴스 속성 {0}  
INSP.attribute.outside.init=인스턴스 속성이 __init__ 외부에 정의되었습니다.

# PyCallByClassInspection
INSP.NAME.different.class.call=다른 클래스 인스턴스를 사용한 클래스별 메소드 호출
INSP.instance.of.$0.excpected=An instance of {0} expected,not the class itself
INSP.passing.$0.instead.of.$1={1} 대신 {0} 을(를) 전달합니다. 의도적입니까?

# PyMissingOrEmptyDocstringInspection
INSP.NAME.missing.or.empty.docstring=누락되었거나 빈 docstring
INSP.no.docstring=누락된 docstring
INSP.empty.docstring=빈 docstring

# PyUnresolvedReferencesInspection
INSP.NAME.unresolved.refs=해결되지 않는 참조
INSP.module.$0.not.found=모듈 ''{0}''을(를) 찾을 수 없습니다.
INSP.unresolved.ref.$0=확인되지 않은 참조 ''{0}''
INSP.unresolved.ref.$0.for.class.$1=확인되지 않은 ''{1}'' 클래스 속성 참조 ''{0}''
INSP.cannot.find.$0.in.$1=''{1}''에서 참조 ''{0}''을(를) 찾을 수 없습니다.
INSP.unresolved.operator.ref=클래스 ''{0}'' 이(가) ''{1}''을(를) 정의하지 않기 때문에 ''{2}'' 연산자를 인스턴스에서 사용할 수 없습니다.
python.stub=Python 스텁

# PyRedundantParenthesesInspection
INSP.NAME.redundant.parentheses=불필요한 소괄호
INSP.redundant.parens.ignore.empty.lists.of.base.classes=기본 클래스의 빈 리스트 무시
INSP.redundant.parens.ignore.tuples=투플 무시
INSP.redundant.parens.ignore.argument.of.operator=% 연산자 인수 무시

# PySimplifyBooleanCheckInspection
INSP.NAME.check.can.be.simplified=부울 변수 검사를 단순화할 수 있습니다.
INSP.expression.can.be.simplified=표현식을 단순화할 수 있습니다.
INSP.simplify.boolean.check.ignore.comparison.to.zero=0에 대한 비교 무시

# PyIncorrectDocstringInspection
INSP.NAME.incorrect.docstring=잘못된 docstring
INSP.missing.parameter.in.docstring=docstring 내 누락된 매개변수 {0}
INSP.unexpected.parameter.in.docstring=docstring 내 예기치 않은 매개변수

# PyExceptClausesOrderInspection
INSP.NAME.bad.except.clauses.order=잘못된 except 절 순서
INSP.class.$0.already.caught=예외 클래스 ''{0}'' 이(가) 이미 포착되었습니다.
INSP.class.$0.superclass.$1.already.caught=''{0}'',superclass of exception class ''{1}'',has already been caught

#PyGlobalUndefinedInspection
INSP.NAME.global.undefined=전역 변수가 모듈 수준에서 undefined입니다.
INSP.NAME.global.$0.undefined=전역 변수 ''{0}'' 이(가) 모듈 수준에서 undefined입니다.

# PyHighlightingAnnotator
INSP.python.trailing.suffix.not.support=Python은 후행 ''{0}''을(를) 지원하지 않습니다.

# PyInterpreterInspection
python.sdk.no.interpreter.configured.owner={0}에 대해 구성된 파이썬 인터프리터가 없습니다.

# PyInspectionsSuppressor
INSP.python.suppressor.suppress.for.function=함수 억제
INSP.python.suppressor.suppress.for.class=클래스 억제
INSP.python.suppressor.suppress.for.statement=구문 억제

find.usages.unnamed=<unnamed>
find.usages.keyword.argument=키워드 인수
find.usages.variable=변수
find.usages.imported.module.alias=가져온 모듈 별칭
find.usages.class=클래스
find.usages.function=함수
find.usages.method=메소드
find.usages.parameter=매개 변수

python.find.usages=사용 위치 찾기
python.find.usages.base.method.question=메소드 {0} 이(가) 클래스 {1} 메소드를 재정의합니다.\n\
기본 메소드의 사용 위치를 찾으시겠습니까?
python.find.usages.usage.in.superclass.list=상위 클래스 목록 내 사용 위치
python.find.usages.usage.in.isinstance=isinstance() 내 사용 위치
python.find.usages.untyped.probable.usage=유형이 없는 (가능성 있는) 사용 위치
python.find.usages.usage.in.import.statement=import 문 내 사용 위치
