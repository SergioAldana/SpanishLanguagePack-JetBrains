# Copyright 2000-2020 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license that can be found in the LICENSE file.

########################################################################################################################
# Groovy script template
########################################################################################################################
action.groovy.scripting.shell.text=Groovy IDE 스크립팅 쉘
action.Mvc.RunTarget.text=명령어 실행
action.Mvc.RunTarget.description=임의의 Grails/Griffon 명령어 실행
action.Mvc.Upgrade.text=SDK 버전 변경
action.Mvc.Upgrade.description=Grails/Griffon SDK 버전 변경
group.Mvc.Actions.text=Grails/Griffon
action.Groovy.Shell.text=Groovy 쉘...
action.Groovy.Shell.description=Groovy 쉘 시작
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.text=propertyMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGeneratePropertyMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.text=methodMissing()
action.org.jetbrains.plugins.groovy.actions.generate.missing.GroovyGenerateMethodMissingAction.description=액션이 propertyMissing()을 생성합니다
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.text=equals() 및 hashCode()
action.org.jetbrains.plugins.groovy.actions.generate.equals.GroovyGenerateEqualsAction.description=액션이 이제 equals와 hashCode를 생성합니다.
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.text=Getter 및 Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterSetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.text=Setter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateSetterAction.description=setter 생성
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.text=Getter
action.org.jetbrains.plugins.groovy.actions.generate.accessors.GroovyGenerateGetterAction.description=getter 생성
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.text=생성자
action.org.jetbrains.plugins.groovy.actions.generate.constructors.GroovyGenerateConstructorAction.description=생성자 생성
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.text=to_String()
action.org.jetbrains.plugins.groovy.actions.generate.tostring.GroovyGenerateToStringAction.description=toString() 메소드를 생성합니다.
action.ExcludeFromStubGeneration.text=스텁 생성에서 제외
action.ExcludeFromStubGeneration.description=컴파일 시 Groovy 파일에 대한 Java 스텁을 생성하지 마십시오
action.DumpGroovyControlFlowAction.text=Groovy 제어 흐름 덤프
action.ConvertToCompileStatic.text=@CompileStatic으로 변환
action.ConvertToCompileStatic.description=Groovy 파일을 @CompileStatic으로 변환
action.ConvertGroovyToJava.text=Java로 변환
action.ConvertGroovyToJava.description=그루비 파일을 Java로 변환
action.Groovy.NewScript.text=Groovy 스크립트
action.Groovy.NewScript.description=새 Groovy 스크립트 생성
action.Groovy.NewClass.text=Groovy 클래스
action.Groovy.NewClass.description=새 Groovy 클래스 생성
action.Groovy.CheckResources.Rebuild.text=리소스 다시 빌드(_R)
action.Groovy.CheckResources.Rebuild.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대한 컴파일러 실행
action.Groovy.CheckResources.Make.text=리소스 빌드(_B)
action.Groovy.CheckResources.Make.description=컴파일 문제 확인을 위해 리소스 루트의 Groovy 파일에 대한 증분 컴파일러 실행
group.Groovy.CheckResources.text=Groovy 리소스(_O)
group.Groovy.CheckResources.description=컴파일 문제 확인을 위해 리소스 루트의 모든 Groovy 파일에 대한 컴파일러 실행
action.Groovy.Shell.Execute.text=Groovy 코드 실행
action.Groovy.Shell.Execute.description=콘솔에서 Groovy 코드 실행

file.template.group.title.groovy=Groovy

groovy.term.class=클래스
groovy.term.interface=인터페이스
groovy.term.trait=특성
groovy.term.enum=열거형
groovy.term.annotation=어노테이션
groovy.term.method=메소드
groovy.term.field=필드
groovy.term.property=프로퍼티
groovy.term.parameter=매개 변수
groovy.term.variable=지역 변수
groovy.term.binding=스크립트 바인딩 변수
groovy.term.label=라벨
groovy.term.closure=클로저
groovy.term.expression=표현식

newclass.dlg.title=새 Groovy 클래스
newclass.menu.action.text=Groovy 클래스
newclass.menu.action.description=새 Groovy 클래스 생성
newscript.dlg.prompt=새 Groovy 스크립트의 이름을 입력하세요
newscript.menu.action.text=Groovy 스크립트
newscript.menu.action.description=새 Groovy 스크립트 생성
##########################################################################################################################
# GDK & compilation
########################################################################################################################

cannot.compile=컴파일할 수 없습니다
debug.option=디버그 스택 트레이스 활성화(&D)
groovy.debug.disable.specific.methods=특정 Groovy 클래스로 스텝인투 안 함(&I)
groovy.debug.caption=Groovy

########################################################################################################################
# Parser error messages
########################################################################################################################
identifier.expected=식별자가 필요합니다
identifier.or.block.expected=식별자 또는 코드 블록이 필요합니다.
string.end.expected=문자열 끝부분이 필요합니다.
try.without.catch.finally='try'에 'catch' 또는 'finally'가 없습니다.
expression.expected=표현식이 필요합니다
duplicate.modifier=중복 제어자 ''{0}''

########################################################################################################################
# Intentions & error messages
########################################################################################################################
cannot.resolve=심볼 ''{0}'' 을(를) 해결할 수 없습니다
cannot.access=''{0}''에 대한 액세스는 해당 액세스 권한을 초과합니다.
cannot.reference.static=필요한 클래스 한정자인 정적 심볼 ''{0}''을(를) 참조할 수 없습니다.
cannot.reference.non.static=정적 컨텍스트에서 정적이 아닌 심볼 ''{0}''을(를) 참조할 수 없습니다.
cannot.return.from.constructor=생성자에서 객체를 반환할 수 없습니다.
cannot.return.from.void.method='void'를 반환하는 메소드에서 객체를 반환할 수 없습니다.
cannot.return.type=''{1}'' 을(를) 반환하는 메소드에서 ''{0}'' 을(를) 반환할 수 없습니다
cannot.apply.method.or.closure=''{0}''을(를) ''{1}''에 적용할 수 없습니다
cannot.apply.method1=''{1}''의 ''{0}''을(를) ''{2}''에 적용할 수 없습니다
cannot.apply.constructor=''{1}''의 생성자 ''{0}''을(를) ''{2}''에 적용할 수 없습니다.
cannot.apply.default.constructor=클래스''{0}''에 대한 디폴트 생성자를 적용할 수 없습니다.
cannot.instantiate.abstract.class=추상 클래스 ''{0}''을(를) 인스턴스화할 수 없습니다.
cannot.instantiate.interface=인터페이스 ''{0}''을(를) 인스턴스화할 수 없습니다.
missing.required.named.parameter=이름 지정된 필수 매개변수 ''{0}''이(가) 없습니다.
loss.of.precision=정확도가 ''{0}''에서 ''{1}''(으)로 손실될 수 있습니다.
cannot.assign=''{0}''을(를) ''{1}''에 대입할 수 없습니다.
cannot.cast=''{0}''을(를) ''{1}''(으)로 형 변환할 수 없습니다.
multiple.assignments.without.list.expr=정적 유형 검사 모드에서는 오른쪽에 list 표현식이 없는 여러 개의 대입이 지원되지 않습니다.
spread.operator.is.not.available=정적 유형 검사에서는 스프레드 연산자를 인수로서 사용할 수 없습니다.
replace.with.list.literal=list 리터럴로 교체합니다.
replace.with.get.at=색인 액세스로 교체합니다.
incorrect.number.of.values=값의 수가 올바르지 않습니다. 기댓값\: {0}, 현재 값\: {1}
invalid.lvalue=대입할 값이 올바르지 않습니다.
duplicate.class=클래스 ''{0}''이(가) ''{1}''에 이미 있습니다.
duplicate.inner.class=클래스 중복\: ''{0}''
script.generated.with.same.name=스크립트 코드에 대해 생성된 통합 클래스 ''{0}''이(가) 있습니다.
variable.already.defined=변수 ''{0}''은(는) 이미 정의되어 있습니다.
field.already.defined=필드 ''{0}''은(는) 이미 정의되어 있습니다.
import.what=가져오기 ''{0}''
import.class=클래스 가져오기
create.class.family.name=클래스 생성
create.class.text=클래스 {0} 생성
create.interface.text=인터페이스 {0} 생성
create.annotation.text=어노테이션 {0} 생성
static.declaration.in.inner.class=내부 클래스는 정적 선언을 가질 수 없습니다
constructors.are.not.allowed.in.anonymous.class=생성자는 익명 클래스에서 허용되지 않습니다.
no.such.property=프로퍼티 ''{0}''이(가) 없습니다.
change.modifier=''{0}''을(를) {1}(으)로 만들기
change.modifier.not=''{0}''을(를) {1}이(가) 아니도록 만들기
change.modifier.family.name=제어자 변경
parameter.cast.fix={0,number,ordinal}번째 매개변수를 {1}(으)로 형 변환합니다.
action.convert.lambda.to.closure=람다를 클로저로 변환
add.parenthesis.to.lambda.parameter.list=소괄호를 매개변수 목록에 추가
# suppress inspection "UnusedProperty"
packageLocal.visibility.presentation=디폴트 가시성
# suppress inspection "UnusedProperty"
protected.visibility.presentation=protected
# suppress inspection "UnusedProperty"
private.visibility.presentation=private
# suppress inspection "UnusedProperty"
public.visibility.presentation=public
# suppress inspection "UnusedProperty"
abstract.visibility.presentation=abstract
# suppress inspection "UnusedProperty"
static.visibility.presentation=static
# suppress inspection "UnusedProperty"
final.visibility.presentation=final
# suppress inspection "UnusedProperty"
native.visibility.presentation=native
# suppress inspection "UnusedProperty"
synchronized.visibility.presentation=synchronized
# suppress inspection "UnusedProperty"
strictfp.visibility.presentation=strictfp
# suppress inspection "UnusedProperty"
transient.visibility.presentation=transient
# suppress inspection "UnusedProperty"
volatile.visibility.presentation=volatile
# suppress inspection "UnusedProperty"
def.visibility.presentation=def



# {0} - colspan, {1} - method name, {2} - class name, {3} - formal myParameters row, {4} - arguments row
########################################################################################################################
# Compiler
########################################################################################################################
class.already.exists=클래스 ''{0}''이(가) 이미 있습니다.

illegal.combination.of.modifiers=제어자 조합이 올바르지 않습니다
illegal.combination.of.modifiers.abstract.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
modifier.volatile.not.allowed.here=제어자 'volatile'은 여기에서 허용되지 않습니다.
modifier.transient.not.allowed.here=제어자 'transient'는 여기에서 허용되지 않습니다
modifier.0.not.allowed=제어자 ''{0}'' 은(는) 여기에서 허용되지 않습니다
interface.cannot.have.modifier.final=인터페이스는 제어자 'final'을 가질 수 없습니다
script.method.cannot.have.modifier.abstract=스크립트 메소드는 제어자 'abstract'를 가질 수 없습니다
script.cannot.have.modifier.native=스크립트 메소드는 제어자 'native'를 가질 수 없습니다
interface.must.have.no.static.method=인터페이스는 정적 메소드를 가질 수 없습니다.
only.abstract.class.can.have.abstract.method=추상 클래스만이 추상 메소드를 가질 수 있습니다.
anonymous.class.cannot.have.abstract.method=익명 클래스는 추상 메소드를 가질 수 없습니다.
illegal.combination.of.modifiers.volatile.and.final=제어자 'abstract' 및 'final'의 조합이 올바르지 않습니다
variable.cannot.be=변수는 제어자 ''{0}'' 을(를) 가질 수 없습니다
remove.modifier=''{0}'' 제거
not.abstract.method.should.have.body=추상 메소드에 본문이 있어서는 안 됩니다.
cannot.create.class.error.text=클래스 ''{0}''을(를) 생성할 수 없습니다. {1}
cannot.create.class.error.title=클래스를 생성할 수 없음
no.class.in.file.template=파일 템플릿에서 클래스를 찾을 수 없습니다.
error.external=외부 오류
Inner.methods.are.not.supported=내부 메소드가 지원되지 않습니다.
final.class.cannot.be.extended=final 클래스는 확장할 수 없습니다.

# Groovy 1.7 checks
unsupported.inner.class.0=내부 클래스는 Groovy {0}에서 지원되지 않습니다.
unsupported.anonymous.class.0=익명 클래스는 Groovy {0}에서 지원되지 않습니다.

# Groovy 1.8 checks
unsupported.diamonds.0=다이아몬드는 Groovy {0}에서 지원되지 않습니다.
unsupported.command.syntax.0=명령어 표현식 구문은 Groovy {0}에서 지원되지 않습니다.
unsupported.dollar.slashy.string.0=달러 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.
unsupported.multiline.slashy.string.0=여러 줄 슬래시 문자열은 Groovy {0}에서 지원되지 않습니다.

#Groovy 2.3 checks
unsupported.traits.0=특성은 Groovy {0}에서 지원되지 않습니다.

#Groovy 2.5 checks
duplicating.named.parameter=매개변수에 이름이 중복된 매개변수 ''{0}''이(가) 있습니다. {1}
field.should.be.immutable=필드 ''{0}''에 불변 유형이 있어야 하거나 @ImmutableOptions를 사용해 불변 유형으로 선언되어야 합니다.
immutable.options.property.not.exist=프로퍼티 ''{0}''이(가) 없습니다.

#Groovy 3.0 checks
illegal.default.modifier=제어자 'default'는 인터페이스 메소드 내에서만 의미가 있습니다
illegal.default.modifier.fix='default' 제어자 제거
default.modifier.in.old.versions=제어자 'default'는 Groovy 3.0 이후 버전에서 이용할 수 있습니다
unsupported.do.while.statement='do while'은 현재 버전에서 지원되지 않습니다.
unsupported.tuple.declaration.in.for='for' 초기화 내 튜플 선언은 현재 버전에서 지원되지 않습니다
unsupported.multiple.variables.in.for='for' 초기화 내 여러 변수는 현재 버전에서 지원되지 않습니다.
unsupported.expression.list.in.for.update='for' 업데이트 내 여러 표현식은 현재 버전에서 지원되지 않습니다.
unsupported.resource.list='try'는 현재 버전에서 지원되지 않습니다.
unsupported.array.initializers=배열 이니셜라이저는 현재 버전에서 지원되지 않습니다.
operator.is.not.supported.in=연산자 ''{0}''은(는) 현재 버전에서 지원되지 않습니다.
unsupported.negated.in=부정된 'in'은 현재 버전에서 지원되지 않습니다.
unsupported.negated.instanceof=부정된 'instanceof'는 현재 버전에서 지원되지 않습니다.
unsupported.elvis.assignment=elvis 대입은 현재 버전에서 지원되지 않습니다.
unsupported.safe.index.access=안전한 색인 액세스는 현재 버전에서 지원되지 않습니다.
unsupported.lambda=람다는 현재 버전에서 지원되지 않습니다.
unsupported.type.annotations=유형 어노테이션은 현재 버전에서 지원되지 않습니다.
illegal.single.argument.lambda=단일 인수는 대입 표현식의 오른쪽 부분에 또는 메소드 호출 내에 인수로서 사용할 수 있습니다.

#Override and implement
method.is.not.implemented=메소드 ''{0}''이(가) 구현되어 있지 않습니다.
change.implements.and.extends.classes=extends 및 implements 목록을 정규화

fix.package.name=패키지 이름 수정

#dynamic properties
add.dynamic.property=동적 프로퍼티 ''{0}'' 추가
duplicate.element.in.the.map=맵 내 중복 요소 ''{0}''
dynamic.tool.window.id=동적 숫자

create.field.from.usage.family.name=사용 위치에서 필드 생성
create.field.from.usage=필드 ''{0}'' 생성
create.method.from.usage.family.name=사용 위치에서 메소드 생성
create.method.from.usage=메소드 ''{0}''을(를) 생성합니다.
create.variable.from.usage.family.name=사용 위치에서 변수 생성
create.variable.from.usage=변수 ''{0}'' 생성
create.parameter.from.usage.family.name=사용 위치에서 매개변수 생성
create.parameter.from.usage=매개변수 ''{0}'' 생성
add.dynamic.element=동적 요소 추가
add.dynamic.method=동적 메소드 추가
dynamic.type=유형
dynamic.name=이름
dynamic.properties.table.name=메소드 인수
dynamic.method.return.type=반환 유형(&T)\:
dynamic.method.property.type=프로퍼티 유형(&T)\:
are.you.sure.to.delete.dynamic.property=''{0}'' 을(를) 삭제하시겠습니까?
dynamic.property.deletion=동적 프로퍼티 삭제
are.you.sure.to.delete.elements=''{0}'' 요소를 삭제하시겠어요''?
dynamic.element.deletion=동적 요소 삭제
tuple.cant.be.placed.in.class=필드에 대한 여러 대입이 허용되지 않습니다
unknown.class=알 수 없는 클래스 ''{0}''
is.not.enclosing.class=''{0}'' 이(가) 둘러싸는 클래스가 아닙니다
package.definition.cannot.have.modifiers=패키지 정의는 제어자를 가질 수 없습니다
import.statement.cannot.have.modifiers=import 문은 제어자를 가질 수 없습니다
undefined.label=정의되지 않은 라벨 ''{0}''
continue.outside.loop=continue 문은 루프 내에서만 허용됩니다.
break.outside.loop.or.switch=break 문은 루프 또는 switch 내에서만 허용됩니다.
label.already.used=라벨 ''{0}''은(는) 이미 사용 중입니다.
break.outside.loop=이름 지정된 라벨이 있는 break 문은 루프 내에서만 허용됩니다.

Constructor=생성자
Getter=Getter
Setter=Setter
compile.groovy.files=Groovy 파일 컴파일(&C)
not.allowed.modifier.in.for.in=제어자 ''{0}'' 은(는) 여기에서 허용되지 않습니다
property.name.expected=프로퍼티 이름이 필요합니다
add.method.body=메소드 본문을 추가합니다.
wildcards.are.not.allowed.in.extends.list=super 유형은 wildcard 유형을 지정할 수 없습니다.
method.does.not.override.super=메소드가 상위 클래스의 메소드를 재정의하지 않습니다.
method.duplicate=시그니처 {0} 이(가) 포함된 메소드는 클래스 ''{1}'' 에 이미 정의되어 있습니다
ambiguous.code.block=모호한 코드 블록
cyclic.inheritance.involving.0=''{0}'' 관련 순환 상속
there.is.no.default.constructor.available.in.class.0=''{0}''에서 사용할 수 있는 디폴트 생성자가 없습니다.
groovy.library.is.not.configured.for.module=Groovy SDK가 모듈 ''{0}''에 대해 구성되지 않았습니다
configure.groovy.library=Groovy SDK 구성...
create.instance.of.built-in.type=기본 유형의 인스턴스화
incorrect.variable.name=잘못된 변수 이름
no.interface.expected.here=여기에서는 인터페이스가 필요하지 않습니다
no.class.expected.here=여기에서는 클래스가 필요하지 않습니다
move.to.extends.list=참조를 extends 목록으로 이동
move.to.implements.list=참조를 implements 목록으로 이동
script.file.is.not.groovy.file=스크립트 파일이 Groovy 파일이 아닙니다
class.does.not.exist=클래스가 없습니다.
class.cannot.be.executed=클래스를 실행할 수 없습니다
invoke.completion.second.time.to.show.skipped.methods=코드 완성을 2번째 호출하여 건너뛴 메소드 표시
groovy.file.extension.is.not.mapped.to.groovy.file.type=*.groovy 파일이 ''{0}''(으)로 매핑되었습니다.\n해당 파일은 설정 | 파일 유형에서 Groovy로 매핑할 수 있습니다.
class.is.not.annotation=''{0}''이(가) 어노테이션이 아닙니다
method.call.is.ambiguous=메소드 호출이 모호합니다.
operator.call.is.ambiguous=연산자 호출이 모호합니다.
duplicated.named.parameter=이름이 중복된 매개변수 ''{0}''이(가) 발견되었습니다.
no.super.classes.found=상위 클래스를 찾을 수 없습니다.
no.super.method.found=상위 메소드를 찾을 수 없습니다.
wrong.package.name=패키지 이름 ''{0}''이(가) 파일 경로 ''{1}''에 해당하지 않습니다.
cannot.assign.string.to.enum.0=문자열을 열거형 ''{0}''에 대입할 수 없습니다.
cannot.find.enum.constant.0.in.enum.1=열거형 ''{1}''에서 열거형 상수 ''{0}''을(를) 찾을 수 없습니다.
recursive.constructor.invocation=재귀 생성자 호출
the.usage.of.a.map.entry.expression.to.initialize.an.enum.is.currently.not.supported=열거형을 초기화하는 맵 항목 표현식의 사용은 현재 지원되지 않습니다.
class.definition.is.not.expected.here=여기에서는 클래스 정의가 필요하지 않습니다.
move.class.0.from.method=올바른 위치로 ''{0}'' 이동
move.class.from.method.family.name=올바른 위치로 이동하는 빠른 수정
constructor.call.is.ambiguous=생성자 호출이 모호합니다.
cannot.infer.argument.types=인수 유형을 추론할 수 없습니다.
Equals=상등
default.initializers.are.not.allowed.in.abstract.method=기본 이니셜라이저는 추상 메소드에서 허용되지 않습니다
groovy.does.not.support.constructor.type.arguments=Groovy는 생성자 유형 인수를 지원하지 않습니다.
illegal.escape.character.in.string.literal=문자열 리터럴의 올바르지 않은 이스케이프 문자
add.parentheses=소괄호 추가
method.with.type.parameters.should.have.return.type=유형 매개변수가 있는 메소드에는 반환 유형이 있어야 합니다
primitive.type.parameters.are.not.allowed=기본 유형 매개변수는 유형 매개변수 목록에서 허용되지 않습니다.
primitive.bound.types.are.not.allowed=기본 바운드 유형은 허용되지 않습니다.
ellipsis.type.is.not.allowed.here=여기에서는 ellipsis 유형이 허용되지 않습니다.
method.0.is.too.complex.too.analyze=메소드 ''{0}''이(가) 너무 복잡하여 분석할 수 없습니다.\n지역 변수 유형이 추론되지 않았습니다.
closure.is.too.complex.to.analyze=클로저가 너무 복잡하여 분석할 수 없습니다.\n지역 변수 유형이 추론되지 않았습니다.
0.is.deprecated=''{0}'' 은(는) 더 이상 사용되지 않습니다
wrong.number.of.type.arguments=유형 인수의 개수가 잘못되었습니다\: {0}; 필요\: {1}
type.argument.0.is.not.in.its.bound.should.extend.1=유형 매개변수 ''{0}''이(가) 해당 바운드 내에 없으며, ''{1}''을(를) 확장해야 합니다.
catch.statement.parameter.type.should.be.a.subclass.of.throwable=catch 문 매개변수 유형은 Throwable의 하위 클래스여야 합니다.
exception.0.has.already.been.caught=예외 ''{0}'' 이(가) 이미 포착되었습니다
unnecessary.type=예외 ''{0}''은(는) 필요하지 않습니다. ''{1}''은(는) 이미 선언되었습니다.
create.enum=열거형 {0} 생성
create.trait=특성 {0} 생성
create.inner.class=내부 클래스 {0} 생성
annotation.field.can.only.be.used.within.a.script.body=어노테이션 @Field는 스크립트 본문 내에서만 사용할 수 있습니다.
annotation.field.can.only.be.used.within.a.script=어노테이션 @Field는 스크립트 내에서만 사용할 수 있습니다.
return.type.is.incompatible={1} 내 {0} 의 반환 유형이 {3} 내 {2} 와(과) 호환되지 않습니다
anonymous.class.derived.from.0={0}에서 파생된 익명 클래스
throws.clause.is.not.allowed.in.at.interface='throws' 절은 @interface 멤버에서 허용되지 않습니다.
at.interface.0.does.not.contain.attribute=@interface ''{0}''에 속성 ''{1}''이(가) 없습니다.
duplicate.attribute=중복 속성
missed.attributes=누락된 속성\: {0}
unexpected.attribute.type.0=예기치 않은 속성 유형\: ''{0}''
annotation.attribute.should.have.return.type.declaration=어노테이션 속성에는 반환 유형 선언이 있어야 합니다.
annotation.field.should.have.type.declaration=어노테이션 내 필드에는 유형 선언이 있어야 합니다.
interface.members.are.not.allowed.to.be=인터페이스 멤버는 {0}이(가) 될 수 없습니다.
abstract.method.cannot.be.final=추상 메소드는 final일 수 없습니다.
abstract.methods.must.not.have.body=추상 메소드에 본문이 있어서는 안 됩니다.
method.has.incorrect.modifier.volatile=메소드에 있는 제어자 'volatile'이 올바르지 않습니다
native.methods.cannot.have.body=네이티브 메소드는 본문을 가질 수 없습니다.
top.level.class.may.not.have.private.modifier=최상위 클래스는 'private' 제어자를 가질 수 없습니다
top.level.class.may.not.have.protected.modifier=최상위 클래스는 'protected' 제어자를 가질 수 없습니다
property.missing=propertyMissing
attribute.name.expected=속성 이름이 필요합니다.
java.style.for.each.statement.requires.a.type.declaration=Java 스타일의 for-each 문에는 유형 선언이 필요합니다.
super.cannot.be.used.in.static.context='super'는 정적 컨텍스트에서 사용할 수 없습니다.
qualified.0.is.allowed.only.in.nested.or.inner.classes=한정된 {0} 은(는) 중첩/내부 클래스에서만 허용됩니다.
groovy.file.0=Groovy 파일 ''{0}''
type.argument.list.is.not.allowed.here=유형 인수 목록은 여기에서 허용되지 않습니다.
initializers.are.not.allowed.in.interface=이니셜라이저가 인터페이스에서 허용되지 않습니다.
initializer.cannot.have.annotations=이니셜라이저는 어노테이션을 가질 수 없습니다.
initializer.cannot.be.0=이니셜라이저는 {0}이(가) 될 수 없습니다.
constructors.are.not.allowed.in.interface=생성자가 인터페이스에서 허용되지 않습니다.
type.parameters.are.unexpected=예기치 않은 유형 매개변수 입니다
constructors.cannot.have.return.type='return' 유형 요소는 생성자에서 허용되지 않습니다.
constructor.cannot.have.static.modifier=생성자는 정적일 수 없습니다.
annotation.types.may.not.have.extends.clause=어노테이션 유형은 'extends' 절을 가질 수 없습니다.
annotation.types.may.not.have.implements.clause=어노테이션 유형은 'implements' 절을 가질 수 없습니다.
no.implements.clause.allowed.for.interface=인터페이스는 'implements' 절을 가질 수 없습니다.
enums.may.not.have.extends.clause=열거형은 'extends' 절을 가질 수 없습니다.
method.0.cannot.override.method.1.in.2.overridden.method.is.final=메소드 ''{0}''은(는) ''{2}''에서 메소드 ''{1}''을(를) 재정의할 수 없으며, 재정의된 메소드는 final입니다.
method.0.cannot.have.weaker.access.privileges.1.than.2.in.3.4=메소드 ''{0}''은(는) ''{3}''(''{4}'')에서 ''{2}''보다 약한 액세스 권한(''{1}'')을 가질 수 없습니다.
tuple.declaration.should.end.with.def.modifier=튜플 선언은 'def' 제어자로 끝나야 합니다
injection.should.not.contain.line.feeds=GString 삽입에 줄 피드가 포함되면 안 됩니다.
collection.literal.contains.named.argument.and.expression.items=컬렉션 리터럴에는 이름 지정된 인수 및 표현식 인수가 동시에 포함됩니다.
annotation.collector.cannot.have.attributes=@AnnotationCollector로 추가된 어노테이션 유형은 속성을 가질 수 없습니다
annotation.type.cannot.be.inner=어노테이션 유형은 내부형일 수 없습니다.
cannot.find.operator.overload.method=인수 {0}(으)로 색인 액세스를 해결할 수 없습니다.
named.arguments.are.not.allowed.inside.index.operations=이름 지정된 인수는 색인 연산 내에서 허용되지 않습니다.
expected.0.to.be.inline.constant=''{0}''은(는) 인라인 상수여야 합니다.
cannot.assign.a.value.to.final.field.0=final 필드 ''{0}''에 값을 대입할 수 없습니다.
cannot.assign.a.value.to.final.parameter.0=final 매개변수 ''{0}''에 값을 대입할 수 없습니다.
variable.0.might.not.have.been.initialized=변수 ''{0}'' 이(가) 초기화 되지 않았을 수 있습니다
doc.end.expected='*/' 이(가) 필요합니다
mixing.private.and.public.protected.methods.of.the.same.name=이름이 같은 private 및 public/protected 메소드가 혼재되어 있습니다.
explicit.constructors.are.not.allowed.in.immutable.class=명시적 생성자는 @Immutable 클래스에서 허용되지 않습니다.
repetitive.method.name.0=메소드 이름 ''{0}''이 반복됩니다.
declared.type.0.have.to.extend.script=선언된 유형 ''{0}''이(가) ''groovy.lang.Script'' 클래스를 확장하지 않습니다.
base.script.annotation.is.allowed.only.inside.scripts=어노테이션 @BaseScript는 스크립트 내에서만 사용할 수 있습니다.
delegate.annotation.is.only.for.methods.without.arguments=어노테이션 @Delegate는 인수를 가진 메소드에 적용할 수 있습니다.
builder.annotation.not.support.super.for.simple.strategy=어노테이션 속성 'includeSuperProperties'는 groovy.transform.builder.SimpleStrategy에서 지원되지 않습니다.
0.expressions.on.trait.fields.properties.are.not.supported.in.traits=특성 필드/프로퍼티에 있는 {0} 표현식은 특성에서 지원되지 않습니다.
only.traits.expected.here=여기에는 특성만이 필요합니다.
anonymous.classes.cannot.be.created.from.traits=익명 클래스는 특성에서 생성할 수 없습니다.
trait.method.cannot.be.protected=특성 메소드는 protected가 될 수 없습니다.
non.static.classes.not.allowed=비정적 내부 클래스는 특성에서 허용되지 않습니다.
selfType.class.does.not.inherit=@SelfType\: 클래스 ''{0}''은(는) ''{1}''을(를) 상속하지 않습니다.
illegal.type.void=올바르지 않은 유형\: 'void'
illegal.method.name=메소드 이름에 잘못된 문자가 았습니다. {0}

select.module.description=클래스 경로를 사용할 모듈은 무엇인가요?
select.module.title=모듈 선택...
### Inspection groups ###
inspection.annotations=어노테이션 검증
inspection.assignments=대입 이슈
inspection.bugs=발생할 수 있는 버그
inspection.confusing=코드 구문이 혼동될 수 있습니다.
inspection.control.flow=제어 흐름 이슈
inspection.data.flow=데이터 흐름
inspection.error.handling=오류 처리
inspection.gpath=GPath
inspection.naming=이름 생성 규칙
inspection.method.metrics=메소드 메트릭
inspection.redundancy=선언 중복성
inspection.threading=스레딩 문제
inspection.validity=유효성 이슈
inspection.style=스타일
inspection.other=기타
### Inspections ###
inspection.display.name.result.of.assignment.used=대입 결과 사용
inspection.display.name.assignment.can.be.operator.assignment=연산자 대입으로 대체 가능한 대입
inspection.display.name.delegates.to=@DelegatesTo 검사
inspection.display.name.unresolved.access=해결되지 않은 표현식에 액세스
inspection.display.name.untyped.access=유형이 지정되지 않은 표현식에 액세스
inspection.display.name.list.set.can.be.keyed.access=List.set 호출이 키 액세스일 수 있습니다
inspection.display.name.list.get.can.be.keyed.access=List.get 호출이 키 액세스일 수 있습니다
inspection.display.name.map.put.can.be.keyed.access=Map.put 호출이 키 액세스일 수 있습니다
inspection.display.name.map.get.can.be.keyed.access=Map.get 호출이 키 액세스일 수 있습니다
inspection.display.name.parameter.naming.convention=메소드 매개변수 이름 지정 규칙
inspection.display.name.constant.naming.convention=상수 이름 지정 규칙
inspection.display.name.instance.variable.naming.convention=인스턴스 변수 이름 지정 규칙
inspection.display.name.instance.method.naming.convention=인스턴스 메소드 이름 지정 규칙
inspection.display.name.static.variable.naming.convention=static 변수 이름 지정 규칙
inspection.display.name.static.method.naming.convention=static 메소드 이름 지정 규칙
inspection.display.name.local.variable.naming.convention=지역 변수 이름 지정 규칙
inspection.display.name.class.naming.convention=클래스 이름 지정 규칙
inspection.display.name.groovydoc.check=GroovyDoc 이슈
inspection.display.name.constructor.named.arguments=생성자 호출의 이름 지정된 인수
inspection.display.name.result.of.object.allocation.ignored=객체 대입의 결과가 무시됨
inspection.display.name.divide.by.zero=0으로 나누기
inspection.display.name.infinite.recursion=무한 재귀
inspection.display.name.infinite.loop.statement=무한 루프 문
inspection.display.name.non.short.circuit.boolean=비단락 회로 부울
inspection.display.name.duplicate.switch.branch=switch case 중복
inspection.display.name.gstring.key=GString 맵 키
inspection.display.name.octal.integer=8진 정수
inspection.display.name.overly.complex.boolean.expression=지나치게 복잡한 부울 표현식
inspection.display.name.clashing.trait.methods=trait 메소드 충돌
inspection.display.name.overly.complex.arithmetic.expression=지나치게 복잡한 산술 표현식
inspection.display.name.double.negation=이중 부정
inspection.display.name.pointless.arithmetic=무의미한 산술 표현식
inspection.display.name.empty.statement.body=본문이 비어 있는 구문
inspection.display.name.reassigned.in.closure.local.var=지역 변수가 클로저 또는 익명 클래스에 다시 할당되었습니다
inspection.display.name.result.of.increment.or.decrement.used=사용된 증분 또는 감소의 결과
inspection.display.name.negated.if=부정된 if 조건식
inspection.display.name.in.argument.check=호환되지 않는 'in' 인수 유형
inspection.display.name.negated.conditional=부정된 조건식
inspection.display.name.nested.conditional=중첩된 조건식
inspection.display.name.conditional=조건식
inspection.display.name.nested.switch=부정된 switch 문
inspection.display.name.multiple.return.points.per.method=여러 반환점이 있는 메소드
inspection.display.name.method.with.more.than.three.negations=4개 이상의 부정이 있는 메소드
inspection.display.name.overly.nested.method=지나치게 중첩된 메소드
inspection.display.name.overly.long.method=지나치게 긴 메소드
inspection.display.name.overly.complex.method=지나치게 복잡한 메소드
inspection.display.name.method.parameter.count=매개변수가 너무 많은 메소드
inspection.display.name.while.loop.spins.on.field=while 루프가 필드에서 스핀합니다
inspection.display.name.unsynchronized.method.overrides.synchronized.method=비동기화된 메소드가 동기화된 메소드를 재정의합니다.
inspection.display.name.synchronization.on.variable.initialized.with.literal=리터럴로 초기화된 변수 동기화
inspection.display.name.synchronization.on.non.final.field=비 final 필드 동기화
inspection.display.name.wait.while.not.synchronized=동기화되지 않는 동안 'wait()'
inspection.display.name.wait.call.not.in.loop='wait()'가 루프에 없음
inspection.display.name.notify.while.not.synchronized=동기화되지 않는 동안 'wait()' 또는 'notify()'
inspection.display.name.system.run.finalizers.on.exit=System.runFinalizersOnExit() 호출
inspection.display.name.thread.stop.suspend.resume=Thread.stop(), Thread.suspend() 또는 Thread.resume() 호출
inspection.display.name.nested.synchronized.statement=중첩된 'synchronized' 문
inspection.display.name.synchronized.method=동기화된 메소드
inspection.display.name.synchronization.on.this='this' 동기화
inspection.display.name.empty.sync.block=빈 'synchronized' 블록
inspection.display.name.busy.wait=바쁜 대기
inspection.display.name.public.field.accessed.in.synchronized.context=동기화된 컨텍스트에서 비 private 필드 액세스
inspection.display.name.unconditional.wait=조건 없는 'wait' 호출
inspection.display.name.double.checked.locking=이중 검사된 잠금
inspection.display.name.access.to.static.field.locked.on.instance=static 필드에 대한 액세스가 인스턴스 데이터에서 잠겨 있음
inspection.display.name.change.to.method=메소드로 변경
inspection.display.name.change.to.operator=연산자로 변경
inspection.display.name.unnecessary.alias=불필요한 import 별칭
inspection.display.name.unnecessary.semicolon=불필요한 세미콜론
inspection.display.name.unnecessary.public.modifier=불필요한 'public'
inspection.display.name.unnecessary.def.modifier=불필요한 'def'
inspection.display.name.java.style.properties.invocation=Java 스타일 프로퍼티 액세스
inspection.display.name.trivial.if=중복 'if' 문
inspection.display.name.constant.if.statement=상수 if 문
inspection.display.name.constant.conditional=상수 조건식
inspection.display.name.trivial.conditional=중복 조건식
inspection.display.name.return.from.closure.can.be.implicit='return' 문이 묵시적일 수 있습니다
inspection.display.name.switch.statement.with.no.default=default case가 없는 switch 문
inspection.display.name.final.variable.access=final 변수 액세스
inspection.display.name.unnecessary.return=불필요한 'return' 문
inspection.display.name.unnecessary.continue=불필요한 'continue' 문
inspection.display.name.fallthrough=switch 문의 fallthrough
inspection.display.name.if.statement.with.too.many.branches=브랜치가 너무 많은 if 문
inspection.display.name.if.statement.with.identical.branches=브랜치가 동일한 if 문
inspection.display.name.conditional.can.be.conditional.call=조건식이 조건 호출일 수 있습니다
inspection.display.name.conditional.can.be.elvis=조건식이 elvis일 수 있습니다
inspection.display.name.conditional.with.identical.branches=동일한 브랜치가 있는 조건식
inspection.display.name.loop.statement.that.doesnt.loop=루프를 실행하지 않는 루프 문
inspection.display.name.unreachable.statement=도달할 수 없는 구문
inspection.display.name.continue=continue 문
inspection.display.name.break=break 문
inspection.display.name.unused.catch.parameter=사용되지 않은 catch 매개변수
inspection.display.name.empty.try.block=빈 'try' 블록
inspection.display.name.empty.finally.block=빈 'finally' 블록
inspection.display.name.empty.catch.block=빈 'catch' 블록
inspection.display.name.throw.from.finally.block='finally' 블록 내 'throw'
inspection.display.name.return.from.finally.block='finally' 블록 내 'return'
inspection.display.name.method.may.be.static=메소드가 static일 수 있습니다.
inspection.display.name.continue.or.break.from.finally.block='finally' 블록 내 'continue' 또는 'break'
inspection.display.name.unchecked.assignment.of.member.of.raw.type=원시 유형 구성원에서 검증되지 않은 대입
inspection.display.name.silly.assignment=잘못된 대입
inspection.display.name.nested.assignment=중첩된 대입
inspection.display.name.assignment.to.method.parameter=메소드 매개변수에 대입
inspection.display.name.assignment.to.for.loop.parameter=for-loop 매개변수에 대입
inspection.display.name.assignability.check=호환되지 않는 유형 대입
inspection.display.name.type.customizer=유형 사용자 지정자 검사
inspection.display.name.unused.declaration=사용되지 않는 선언
inspection.display.name.second.unsafe.call=두 번째 안전하지 않은 호출
inspection.display.name.unused.assignment=사용하지 않는 대입
inspection.display.name.unused.inc.dec=사용되지 않은 증분 또는 감소
inspection.display.name.unassigned.access=변수가 할당되지 않았습니다
inspection.display.name.no.return=return 문 누락
inspection.display.name.clashing.getters=getter 충돌
inspection.display.name.package.mismatch=패키지 불일치
inspection.display.name.deprecated.api.usage=더 이상 사용되지 않는 API 검사
inspection.display.name.unnecessary.qualified.reference=불필요한 정규화된 참조
inspection.display.name.pointless.boolean=무의미한 부울 표현식
inspection.display.name.access.to.inaccessible.element=액세스할 수 없는 요소에 액세스
inspection.display.name.incorrect.range.argument=올바르지 않은 범위 인수
inspection.display.name.new.instance.of.singleton=@groovy.lang.Singleton 어노테이션이 추가된 클래스의 새 인스턴스
inspection.display.name.check.labeled.statement=라벨 지정된 구문 검사
inspection.display.name.variable.can.be.final=변수가 final일 수 있습니다
inspection.display.name.equals.between.inconvertible.types=변환할 수 없는 유형의 객체 간의 'equals()'
inspection.display.name.singleton.constructor=@Singleton 생성자
### Intention groups ###
intention.category.groovy=Groovy
intention.category.conversions=Groovy/표현식 변환
intention.category.closures=Groovy/클로저
intention.category.comments=Groovy/주석
intention.category.groovy.style=Groovy/Groovy 스타일
intention.category.control.flow=Groovy/제어 흐름
intention.category.groovy.declaration=Groovy/선언
intention.category.groovy.other=Groovy/기타
configurable.GroovyCompilerConfigurable.display.name=Groovy 컴파일러
configurable.GantConfigurable.display.name=Gant
settings.compiler.alternative=다른 방법으로, <a href\=\"\#\">Java 컴파일러 페이지</a>에서 Groovy-Eclipse 컴파일러를 지정할 수 있습니다.
settings.compiler.select.path.to.groovy.compiler.configscript=Groovy 컴파일러의 구성 스크립트 경로 선택
settings.compiler.path.to.configscript=구성 스크립트 경로(&C)\:
settings.compiler.invoke.dynamic.support=동적 지원 실행(&D)
settings.compiler.exclude.from.stub.generation=스텁 생성에서 제외\:
settings.code.style.label.indent.style=레이블 들여쓰기 스타일\:
settings.code.style.label.indent.size=라벨 들여쓰기 크기\:
settings.code.style.indent.statements.after.label=레이블 다음 명령문 들여쓰기
settings.code.style.absolute=절대
settings.code.style.indent.labels=레이블 들여쓰기
settings.inlay.parameter.types=매개변수 유형
settings.inlay.inferred.parameter.types=추론된 매개변수 유형
settings.inlay.type.parameter.list=유형 매개변수 목록
settings.inlay.show.type.hints.for=다음에 대한 유형 힌트 표시\:
checkbox.delegate.via.overloading.method=오버로드 메소드를 통한 위임
