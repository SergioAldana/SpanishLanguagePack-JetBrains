#
# Copyright 2000-2007 JetBrains s.r.o.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

########################################################################################################################
# Introduce variable
########################################################################################################################
introduce.variable.title=변수 삽입
only.in.groovy.files=이 리팩토링은 Groovy 파일에서만 사용할 수 있습니다.
selected.block.should.represent.an.expression=선택한 블록이 표현식을 나타내야 합니다.
refactoring.is.not.supported.in.the.current.context=리팩토링이 현재 컨텍스트에서 지원되지 않습니다.
refactoring.is.not.supported.in.method.parameters=리팩토링이 클로저 또는 메소드 매개변수에서 지원되지 않습니다.
replace.all.occurrences=모든 사용 위치 교체
declare.final=final 선언
press.escape.to.remove.the.highlighting=강조 표시를 제거하려면 ESC를 누릅니다.
specify.the.type.explicitly=유형을 명시적으로 지정
variable.of.type=유형의 변수\:
selected.expression.has.void.type=선택한 표현식에 void 유형이 있습니다
selected.expression.in.command.expression=선택한 표현식은 명령어 표현식의 일부입니다.
introduced.variable.conflicts.with.parameter.0=삽입된 변수가 매개변수 {0}와(과) 충돌합니다.
introduced.variable.conflicts.with.variable.0=삽입된 변수가 지역 변수 {0}와(과) 충돌합니다.

########################################################################################################################
# Inline variable
########################################################################################################################
inline.variable.title=변수 인라인화
variable.is.never.used.0=변수 ''{0}'' 이(가) 사용되지 않습니다
field.is.never.used.0=필드 ''{0}'' 이(가) 사용되지 않습니다
wrong.element.to.inline=캐럿이 Groovy 메소드 또는 지역 변수 이름 위에 있어야 합니다
cannot.find.a.single.definition.to.inline.local.var=지역 변수를 인라인화할 단일 정의를 찾을 수 없습니다.
cannot.find.a.single.definition.to.inline.field=해당 필드에 대한 이니셜라이저가 존재하지 않습니다.
inline.local.command=변수 인라인화
local.varaible.is.lvalue=인라인화할 변수가 대입의 lvalue로서 사용됩니다
inline.local.variable.prompt.0.1=지역 변수 ''{0}''을(를) 인라인화하시겠어요?

########################################################################################################################
# Extract method
########################################################################################################################
extract.method.title=메소드 추출
selected.block.should.represent.a.statement.set=선택한 블록은 구문 또는 표현식 모음을 나타내야 합니다.
multiple.output.values=선택한 코드 조각에 여러 출력 값이 있습니다.
selected.block.contains.invocation.of.another.class.constructor=선택한 블록에 다른 클래스 생성자의 호출이 포함되어 있습니다.
specify.type.label=반환 유형을 명시적으로 지정(&T)
name.label=이름(&N)\:
signature.preview.border.title=시그니처 미리보기
parameters.border.title=매개 변수
visibility.border.title=가시성
method.border.title=메소드
visibility.private=Private
visibility.public=Public
visibility.protected=Protected
row.move.up=위로 이동
row.move.down=아래로 이동
method.is.already.defined.in.class=메소드 {0} 은(는) 클래스 {1}에 이미 정의되어 있습니다.
method.is.already.defined.in.script=메소드 {0} 은(는) 스크립트 {1}에 이미 정의되어 있습니다.

########################################################################################################################
# Inline method
########################################################################################################################
inline.refactoring.title=인라인
inline.method.title=인라인 메소드
inline.method.border.title=인라인
inline.method.label=메소드 {0}
all.invocations.and.remove.the.method=모든 호출 인라인화 및 메소드 제거(&A)
all.invocations.in.project=프로젝트 내 모든 호출 인라인화(&A)
this.invocation.only.and.keep.the.method=이 호출만 인라인화 및 메소드 유지(&T)
refactoring.cannot.be.applied.to.abstract.methods=리팩토링은 추상 메소드에 적용할 수 없습니다.
refactoring.cannot.be.applied.no.sources.attached=연결된 소스가 없어 리팩토링을 적용할 수 없습니다.
refactoring.is.not.supported.when.return.statement.interrupts.the.execution.flow=Return 문이 실행 흐름을 방해할 때 리팩토링이 지원되지 않습니다.
refactoring.is.not.supported.for.recursive.methods=리팩토링은 재귀 메소드에서 지원되지 않습니다.
refactoring.cannot.be.applied.to.constructors=리팩토링은 생성자에 적용할 수 없습니다.
refactoring.is.not.supported.in.parameter.initializers=리팩토링이 매개변수 이니셜라이저에서 지원되지 않습니다.
inline.method.prompt.0=메소드 ''{0}'' 호출을 인라인화하시겠어요?
refactoring.is.available.only.for.method.calls=리팩토링은 메소드 호출에서만 사용할 수 있습니다.
method.is.not.accessible.form.context.0=인라인화된 메소드에 사용되는 메소드 {0} 은(는) 호출 사이트에서 액세스할 수 없습니다.
field.is.not.accessible.form.context.0=인라인화된 메소드에 사용되는 필드 {0} 은(는) 호출 사이트에서 액세스할 수 없습니다.
super.reference.is.used=인라인화된 메소드에서 사용된 상위 호출은 인라인화 후에 유효하지 않게 됩니다.

########################################################################################################################
# Inline method
########################################################################################################################
variable.conflicts.with.parameter.0=선택한 이름이 매개변수 {0}와(과) 충돌합니다.
variable.conflicts.with.variable.0=선택한 이름이 지역 변수 {0}와(과) 충돌합니다.
variable.conflicts.with.field.0=선택한 이름이 필드 {0}와(과) 충돌합니다.

########################################################################################################################
# Introduce Parameter
########################################################################################################################
introduce.parameter.title=매개변수 삽입
groovy.does.not.support.inner.classes.but.it.is.used.in.parameter.initializer=Groovy에서 내부 클래스를 지원하지 않지만 매개변수 이니셜라이저에서 사용됩니다.
groovy.does.not.support.anonymous.classes.but.it.is.used.in.parameter.initializer=Groovy에서 익명 클래스를 지원하지 않지만 매개변수 이니셜라이저에서 사용됩니다.
error.wrong.caret.position.method.name=캐럿이 리팩토링할 메소드 이름에 위치해야 합니다.

########################################################################################################################
# Change signature
########################################################################################################################
changeSignature.refactoring.name=시그니처 변경
column.name.type=유형
column.name.name=이름
column.name.default.initializer=이니셜라이저
column.name.default.value=디폴트 값
method.duplicate=시그니처 {0} 이(가) 포함된 메소드는 {1} 에 이미 정의되어 있습니다
replace.setter.for.property=프로퍼티 ''{0}''에 대한 디폴트 setter가 덮어쓰기됩니다.
replace.getter.for.property=프로퍼티 ''{0}'' 에 대한 디폴트 getter가 덮어쓰기됩니다
name.is.wrong=이름 ''{0}''이(가) 잘못되었습니다.
incorrect.data=잘못된 데이터
return.type.is.wrong=반환 유형이 잘못되었습니다.
type.for.parameter.is.incorrect=매개변수 ''{0}''의 유형이 잘못되었습니다.
specify.default.value=매개변수 ''{0}''에 대한 디폴트 값 또는 이니셜라이저 지정
changing.signature.of.0={0}의 시그니처 변경
refactored.method.will.cover.closure.property=리팩토링된 메소드가 {1} 내 클로저 프로퍼티 ''{0}''을(를) 재정의합니다.
changeSignature.not.throwable.type=잘못된 유형\: 예외에 대한 ''{0}''이(가) java.lang.Throwable을 확장해야 합니다.
changeSignature.wrong.type.for.exception=잘못된 유형\: 예외의 ''{0}''
changeSignature.no.type.for.exception=예외에 대한 유형을 지정해야 합니다.
no.occurrences.found=사용 위치를 찾을 수 없습니다.
expression.is.not.constant=선택한 표현식이 상수가 아닙니다.
class.does.not.exists=클래스 {0}이(가) 없습니다.
class.does.not.exist.in.the.module=모듈에 클래스가 없습니다. 클래스를 생성하시겠어요?
closure.uses.external.variables=클로저가 상수가 아닌 외부 변수를 사용합니다.
expression.invokes.not.static.methods=표현식이 정적이 아닌 메소드를 호출합니다.
class.language.is.not.groovy=대상 클래스 언어가 Groovy가 아닙니다.
implicit.getter.will.by.overriden.by.method=메소드 {1} 이(가) 프로퍼티 {0} 의 묵시적 getter를 재정의합니다
implicit.setter.will.by.overriden.by.method=메소드 {1}이(가) 프로퍼티 {0}의 묵시적 setter를 재정의합니다.
usage.of.field.will.be.overriden.by.method=메소드 {1}이(가) 필드의 사용 위치를 재정의합니다.
usage.will.be.overriden.by.method=메소드 {1}이(가) 사용 위치 {0}을(를) 재정의합니다.
target.class.is.not.specified=대상 클래스가 지정되지 않았습니다.
is.not.class.name=''{0}''은(는) 클래스 이름이 아닙니다.
target.class.must.not.be.script=대상 클래스는 스크립트여서는 안 됩니다.
rename.is.not.applicable.to.implicit.elements=묵시적 요소의 이름을 변경할 수 없습니다.
rename.member={0} 이름 변경
rename.property=프로퍼티 ''{0}''의 이름 변경
cannot.introduce.field.in.script=범위에 클래스가 없습니다.
cannot.introduce.field.in.interface=인터페이스에 필드를 삽입할 수 없습니다.
expression.contains.errors=표현식에 오류가 포함되어 있습니다.
field.0.is.already.defined=필드 {0} 은(는) 이미 정의되어 있습니다.
access.to.created.field.0.will.be.overriden.by.method.1={1}이(가) 필드 {0}에 대한 액세스를 재정의합니다.
final.field.cant.be.initialized.in.cur.method=최종 필드는 현재 메소드에서 초기화할 수 없습니다
Field.cannot.be.final.because.replaced.variable.has.lhs.usages=선택한 변수는 쓰기에 사용됩니다.
field.cannot.be.initialized.in.field.declaration=필드는 선언에서 초기화할 수 없습니다.
field.cannot.be.initialized.in.constructor(s)=필드는 생성자에서 초기화할 수 없습니다.
selected.variable.is.used.for.write=선택한 변수는 쓰기에 사용됩니다.
there.is.no.method.or.closure=포함된 메소드 또는 클로저가 없습니다.
remove.parameter.0.no.longer.used=더 이상 사용되지 않는 매개변수 ''{0}'' 제거
convert.to.java.refactoring.name=Java로 변환
convert.to.java.can.work.only.with.groovy=Java로 변환 리팩토링은 Groovy 파일에서만 작동합니다.
files.to.be.converted=변환할 파일
converting.files.to.java=파일을 Java로 변환 중
convert.to.static.refactoring.name=@CompileStatic으로 변환
convert.to.static.can.work.only.with.groovy=@CompileStatic으로 변환 리팩토링은 Groovy 파일에서만 작동합니다.
converting.files.to.static=파일을 @CompileStatic으로 변환 중
intention.converting.to.static=@CompileStatic으로 변환 적용
intention.converting.to.static.family=@CompileStatic으로 변환
rename.groovy.property=Groovy 프로퍼티 이름 변경(&G)
change.usages.of.var=변수 ''{0}''의 사용 위치를 변경하시겠어요?
reference.to.accessor.0.is.used=접근자 <bold>{0}<bold>에 대한 참조는 인라인화할 수 없습니다.
variable.is.accessed.for.writing=변수 ''{0}''은(는) 쓰기용으로 액세스됩니다.
introduce.closure.parameter.elements.header=클로저에 매개변수 추가 중
extract.closure.title=클로저 추출
cannot.process.usage.in.language.{0}={0} 내 사용 위치를 처리할 수 없습니다.
you.cannot.pass.as.parameter.0.because.you.remove.1.from.base.method=메소드에서 관련 매개변수 ''{1}''을(를) 제거하므로 ''{0}''을(를) 매개변수로 전달할 수 없습니다. "이제 사용되지 않는 매개변수 ''{0}''을(를) 제거"를 선택 해제하거나 매개변수 테이블에서 매개변수 ''{1}''을(를) 선택 해제해야 합니다.
rename.groovy.implicit.closure.parameter=묵시적 클로저 매개변수의 이름 변경
rename.implicit.closure.parameter.to=묵시적 클로저 매개변수의 이름을 다음으로 변경\:
implicit.closure.parameter=묵시적 클로저 매개변수
selected.expression.should.not.be.lvalue=선택한 표현식이 대입의 왼쪽에 있어서는 안 됩니다.
column.name.use.any.var=임의의 변수 사용
rename.groovy.method=Groovy 메소드 이름 변경
cannot.inline.0.={0}을(를) 인라인화할 수 없습니다.
ref.0.will.not.be.resolved.outside.of.current.context=참조 ''{0}''은(는) 현재 컨텍스트 외에서는 해결되지 않습니다.
cannot.rename.property.0=메소드 <bold>''{1}''</bold>을(를) 재정의하는 프로퍼티 <bold>''{0}''</bold>의 이름을 변경할 수 없습니다.
cannot.inline.reference.0=참조 ''{0}''을(를) 인라인화할 수 없습니다.
cannot.rename.script.class.to.0=스크립트 클래스 ''{0}''의 이름을 ''{1}''(으)로 변경할 수 없습니다.
